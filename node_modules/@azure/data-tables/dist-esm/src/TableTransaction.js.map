{"version":3,"file":"TableTransaction.js","sourceRoot":"","sources":["../../src/TableTransaction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  DeleteTableEntityOptions,\n  TableEntity,\n  TableTransactionEntityResponse,\n  TableTransactionResponse,\n  TransactionAction,\n  UpdateMode,\n  UpdateTableEntityOptions,\n} from \"./models\";\nimport { NamedKeyCredential, SASCredential, TokenCredential } from \"@azure/core-auth\";\nimport {\n  OperationOptions,\n  ServiceClient,\n  serializationPolicy,\n  serializationPolicyName,\n} from \"@azure/core-client\";\nimport {\n  Pipeline,\n  PipelineRequest,\n  PipelineResponse,\n  RestError,\n  createHttpHeaders,\n  createPipelineRequest,\n} from \"@azure/core-rest-pipeline\";\nimport {\n  getInitialTransactionBody,\n  getTransactionHttpRequestBody,\n} from \"./utils/transactionHelpers\";\nimport {\n  transactionHeaderFilterPolicy,\n  transactionHeaderFilterPolicyName,\n  transactionRequestAssemblePolicy,\n  transactionRequestAssemblePolicyName,\n} from \"./TablePolicies\";\n\nimport { TableClientLike } from \"./utils/internalModels\";\nimport { TableServiceErrorOdataError } from \"./generated\";\nimport { cosmosPatchPolicy } from \"./cosmosPathPolicy\";\nimport { getTransactionHeaders } from \"./utils/transactionHeaders\";\nimport { isCosmosEndpoint } from \"./utils/isCosmosEndpoint\";\nimport { tracingClient } from \"./utils/tracing\";\n\n/**\n * Helper to build a list of transaction actions\n */\nexport class TableTransaction {\n  /**\n   * List of actions to perform in a transaction\n   */\n  public actions: TransactionAction[];\n\n  constructor(actions?: TransactionAction[]) {\n    this.actions = actions ?? [];\n  }\n\n  /**\n   * Adds a create action to the transaction\n   * @param entity - entity to create\n   */\n  createEntity<T extends object = Record<string, unknown>>(entity: TableEntity<T>): void {\n    this.actions.push([\"create\", entity]);\n  }\n\n  /**\n   * Adds a delete action to the transaction\n   * @param partitionKey - partition key of the entity to delete\n   * @param rowKey - rowKey of the entity to delete\n   */\n  deleteEntity(partitionKey: string, rowKey: string): void {\n    this.actions.push([\"delete\", { partitionKey, rowKey }]);\n  }\n\n  /**\n   * Adds an update action to the transaction\n   * @param entity - entity to update\n   * @param updateOptions - options for the update operation\n   */\n  updateEntity<T extends object = Record<string, unknown>>(\n    entity: TableEntity<T>,\n    updateOptions?: UpdateTableEntityOptions\n  ): void;\n\n  /**\n   * Adds an update action to the transaction\n   * @param entity - entity to update\n   * @param updateMode - update mode\n   * @param updateOptions - options for the update operation\n   */\n  updateEntity<T extends object = Record<string, unknown>>(\n    entity: TableEntity<T>,\n    updateMode: UpdateMode,\n    updateOptions?: UpdateTableEntityOptions\n  ): void;\n\n  /**\n   * Adds an update action to the transaction\n   * @param entity - entity to update\n   * @param updateModeOrOptions - update mode or update options\n   * @param updateOptions - options for the update operation\n   */\n  updateEntity<T extends object = Record<string, unknown>>(\n    entity: TableEntity<T>,\n    updateModeOrOptions: UpdateMode | UpdateTableEntityOptions | undefined,\n    updateOptions?: UpdateTableEntityOptions\n  ): void {\n    // UpdateMode is a string union\n    const realUpdateMode: UpdateMode | undefined =\n      typeof updateModeOrOptions === \"string\" ? updateModeOrOptions : undefined;\n    const realUpdateOptions: UpdateTableEntityOptions | undefined =\n      typeof updateModeOrOptions === \"object\" ? updateModeOrOptions : updateOptions;\n    this.actions.push([\"update\", entity, realUpdateMode ?? \"Merge\", realUpdateOptions ?? {}]);\n  }\n\n  /**\n   * Adds an upsert action to the transaction, which inserts if the entity doesn't exist or updates the existing one\n   * @param entity - entity to upsert\n   * @param updateMode - update mode\n   */\n  upsertEntity<T extends object = Record<string, unknown>>(\n    entity: TableEntity<T>,\n    updateMode: UpdateMode = \"Merge\"\n  ): void {\n    this.actions.push([\"upsert\", entity, updateMode]);\n  }\n}\n\n/**\n * TableTransaction collects sub-operations that can be submitted together via submitTransaction\n */\nexport class InternalTableTransaction {\n  /**\n   * Table Account URL\n   */\n  public url: string;\n  /**\n   * State that holds the information about a particular transation\n   */\n  private state: {\n    transactionId: string;\n    changesetId: string;\n    pendingOperations: Promise<any>[];\n    bodyParts: string[];\n    partitionKey: string;\n  };\n  private interceptClient: TableClientLike;\n  private allowInsecureConnection: boolean;\n  private client: ServiceClient;\n\n  /**\n   * @param url - Tables account url\n   * @param partitionKey - partition key\n   * @param credential - credential to authenticate the transaction request\n   */\n  constructor(\n    url: string,\n    partitionKey: string,\n    transactionId: string,\n    changesetId: string,\n    client: ServiceClient,\n    interceptClient: TableClientLike,\n    credential?: NamedKeyCredential | SASCredential | TokenCredential,\n    allowInsecureConnection: boolean = false\n  ) {\n    this.client = client;\n    this.url = url;\n    this.interceptClient = interceptClient;\n    this.allowInsecureConnection = allowInsecureConnection;\n\n    // Initialize the state\n    this.state = this.initializeState(transactionId, changesetId, partitionKey);\n\n    // Depending on the auth method used we need to build the url\n    if (!credential) {\n      // When the SAS token is provided as part of the URL we need to move it after $batch\n      const urlParts = url.split(\"?\");\n      this.url = urlParts[0];\n      const sas = urlParts.length > 1 ? `?${urlParts[1]}` : \"\";\n      this.url = `${this.getUrlWithSlash()}$batch${sas}`;\n    } else {\n      // When using a SharedKey credential no SAS token is needed\n      this.url = `${this.getUrlWithSlash()}$batch`;\n    }\n  }\n\n  private initializeState(transactionId: string, changesetId: string, partitionKey: string) {\n    const pendingOperations: Promise<any>[] = [];\n    const bodyParts = getInitialTransactionBody(transactionId, changesetId);\n    const isCosmos = isCosmosEndpoint(this.url);\n    prepateTransactionPipeline(this.interceptClient.pipeline, bodyParts, changesetId, isCosmos);\n\n    return {\n      transactionId,\n      changesetId,\n      partitionKey,\n      pendingOperations,\n      bodyParts,\n    };\n  }\n\n  /**\n   * Adds a createEntity operation to the transaction\n   * @param entity - Entity to create\n   */\n  public createEntity<T extends object>(entity: TableEntity<T>): void {\n    this.checkPartitionKey(entity.partitionKey);\n    this.state.pendingOperations.push(this.interceptClient.createEntity(entity));\n  }\n\n  /**\n   * Adds a createEntity operation to the transaction per each entity in the entities array\n   * @param entities - Array of entities to create\n   */\n  public createEntities<T extends object>(entities: TableEntity<T>[]): void {\n    for (const entity of entities) {\n      this.checkPartitionKey(entity.partitionKey);\n      this.state.pendingOperations.push(this.interceptClient.createEntity(entity));\n    }\n  }\n\n  /**\n   * Adds a deleteEntity operation to the transaction\n   * @param partitionKey - Partition key of the entity to delete\n   * @param rowKey - Row key of the entity to delete\n   * @param options - Options for the delete operation\n   */\n  public deleteEntity(\n    partitionKey: string,\n    rowKey: string,\n    options?: DeleteTableEntityOptions\n  ): void {\n    this.checkPartitionKey(partitionKey);\n    this.state.pendingOperations.push(\n      this.interceptClient.deleteEntity(partitionKey, rowKey, options)\n    );\n  }\n\n  /**\n   * Adds an updateEntity operation to the transaction\n   * @param entity - Entity to update\n   * @param mode - Update mode (Merge or Replace)\n   * @param options - Options for the update operation\n   */\n  public updateEntity<T extends object>(\n    entity: TableEntity<T>,\n    mode: UpdateMode,\n    options?: UpdateTableEntityOptions\n  ): void {\n    this.checkPartitionKey(entity.partitionKey);\n    this.state.pendingOperations.push(this.interceptClient.updateEntity(entity, mode, options));\n  }\n\n  /**\n   * Adds an upsertEntity operation to the transaction\n   * @param entity - The properties for the table entity.\n   * @param mode   - The different modes for updating the entity:\n   *               - Merge: Updates an entity by updating the entity's properties without replacing the existing entity.\n   *               - Replace: Updates an existing entity by replacing the entire entity.\n   * @param options - The options parameters.\n   */\n  public upsertEntity<T extends object>(\n    entity: TableEntity<T>,\n    mode: UpdateMode,\n    options?: OperationOptions\n  ): void {\n    this.checkPartitionKey(entity.partitionKey);\n    this.state.pendingOperations.push(this.interceptClient.upsertEntity(entity, mode, options));\n  }\n\n  /**\n   * Submits the operations in the transaction\n   */\n  public async submitTransaction(): Promise<TableTransactionResponse> {\n    await Promise.all(this.state.pendingOperations);\n    const body = getTransactionHttpRequestBody(\n      this.state.bodyParts,\n      this.state.transactionId,\n      this.state.changesetId\n    );\n\n    const headers = getTransactionHeaders(this.state.transactionId);\n\n    return tracingClient.withSpan(\n      \"TableTransaction.submitTransaction\",\n      {} as OperationOptions,\n      async (updatedOptions) => {\n        const request = createPipelineRequest({\n          url: this.url,\n          method: \"POST\",\n          body,\n          headers: createHttpHeaders(headers),\n          tracingOptions: updatedOptions.tracingOptions,\n          allowInsecureConnection: this.allowInsecureConnection,\n        });\n\n        const rawTransactionResponse = await this.client.sendRequest(request);\n        return parseTransactionResponse(rawTransactionResponse);\n      }\n    );\n  }\n\n  private checkPartitionKey(partitionKey: string): void {\n    if (this.state.partitionKey !== partitionKey) {\n      throw new Error(\"All operations in a transaction must target the same partitionKey\");\n    }\n  }\n\n  private getUrlWithSlash(): string {\n    return this.url.endsWith(\"/\") ? this.url : `${this.url}/`;\n  }\n}\n\nexport function parseTransactionResponse(\n  transactionResponse: PipelineResponse\n): TableTransactionResponse {\n  const subResponsePrefix = `--changesetresponse_`;\n  const status = transactionResponse.status;\n  const rawBody = transactionResponse.bodyAsText || \"\";\n  const splitBody = rawBody.split(subResponsePrefix);\n  const isSuccessByStatus = 200 <= status && status < 300;\n\n  if (!isSuccessByStatus) {\n    handleBodyError(rawBody, status, transactionResponse.request, transactionResponse);\n  }\n\n  // Dropping the first and last elements as they are the boundaries\n  // we just care about sub request content\n  const subResponses = splitBody.slice(1, splitBody.length - 1);\n\n  const responses: TableTransactionEntityResponse[] = subResponses.map((subResponse) => {\n    const statusMatch = subResponse.match(/HTTP\\/1.1 ([0-9]*)/);\n    if (statusMatch?.length !== 2) {\n      throw new Error(`Couldn't extract status from sub-response:\\n ${subResponse}`);\n    }\n    const subResponseStatus = Number.parseInt(statusMatch[1]);\n    if (!Number.isInteger(subResponseStatus)) {\n      throw new Error(`Expected sub-response status to be an integer ${subResponseStatus}`);\n    }\n\n    const bodyMatch = subResponse.match(/\\{(.*)\\}/);\n    if (bodyMatch?.length === 2) {\n      handleBodyError(\n        bodyMatch[0],\n        subResponseStatus,\n        transactionResponse.request,\n        transactionResponse\n      );\n    }\n\n    const etagMatch = subResponse.match(/ETag: (.*)/);\n    const rowKeyMatch = subResponse.match(/RowKey='(.*)'/);\n\n    return {\n      status: subResponseStatus,\n      ...(rowKeyMatch?.length === 2 && { rowKey: rowKeyMatch[1] }),\n      ...(etagMatch?.length === 2 && { etag: etagMatch[1] }),\n    };\n  });\n\n  return {\n    status,\n    subResponses: responses,\n    getResponseForEntity: (rowKey: string) => responses.find((r) => r.rowKey === rowKey),\n  };\n}\n\nfunction handleBodyError(\n  bodyAsText: string,\n  statusCode: number,\n  request: PipelineRequest,\n  response: PipelineResponse\n) {\n  let parsedError;\n\n  try {\n    parsedError = JSON.parse(bodyAsText);\n  } catch {\n    parsedError = {};\n  }\n\n  let message = \"Transaction Failed\";\n  let code: string | undefined;\n  // Only transaction sub-responses return body\n  if (parsedError && parsedError[\"odata.error\"]) {\n    const error: TableServiceErrorOdataError = parsedError[\"odata.error\"];\n    message = error.message?.value ?? message;\n    code = error.code;\n  }\n\n  throw new RestError(message, {\n    code,\n    statusCode,\n    request,\n    response,\n  });\n}\n\n/**\n * Prepares the transaction pipeline to intercept operations\n * @param pipeline - Client pipeline\n */\nexport function prepateTransactionPipeline(\n  pipeline: Pipeline,\n  bodyParts: string[],\n  changesetId: string,\n  isCosmos: boolean\n): void {\n  // Fist, we need to clear all the existing policies to make sure we start\n  // with a fresh state.\n  const policies = pipeline.getOrderedPolicies();\n  for (const policy of policies) {\n    pipeline.removePolicy({\n      name: policy.name,\n    });\n  }\n\n  // With the clear state we now initialize the pipelines required for intercepting the requests.\n  // Use transaction assemble policy to assemble request and intercept request from going to wire\n\n  pipeline.addPolicy(serializationPolicy(), { phase: \"Serialize\" });\n  pipeline.addPolicy(transactionHeaderFilterPolicy());\n  pipeline.addPolicy(transactionRequestAssemblePolicy(bodyParts, changesetId));\n  if (isCosmos) {\n    pipeline.addPolicy(cosmosPatchPolicy(), {\n      afterPolicies: [transactionHeaderFilterPolicyName],\n      beforePolicies: [serializationPolicyName, transactionRequestAssemblePolicyName],\n    });\n  }\n}\n"]}