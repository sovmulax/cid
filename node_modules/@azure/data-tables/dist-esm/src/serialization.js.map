{"version":3,"file":"serialization.js","sourceRoot":"","sources":["../../src/serialization.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { EdmTypes, SignedIdentifier, TableEntityQueryOptions } from \"./models\";\nimport {\n  QueryOptions as GeneratedQueryOptions,\n  SignedIdentifier as GeneratedSignedIdentifier,\n} from \"./generated/models\";\nimport { base64Decode, base64Encode } from \"./utils/bufferSerializer\";\nimport { truncatedISO8061Date } from \"./utils/truncateISO8061Date\";\n\nconst propertyCaseMap: Map<string, string> = new Map<string, string>([\n  [\"PartitionKey\", \"partitionKey\"],\n  [\"RowKey\", \"rowKey\"],\n  [\"odata.etag\", \"etag\"],\n  [\"Timestamp\", \"timestamp\"],\n]);\n\nconst Edm = {\n  Binary: \"Edm.Binary\",\n  Boolean: \"Edm.Boolean\",\n  DateTime: \"Edm.DateTime\",\n  Double: \"Edm.Double\",\n  Guid: \"Edm.Guid\",\n  Int32: \"Edm.Int32\",\n  Int64: \"Edm.Int64\",\n  String: \"Edm.String\",\n} as const;\n\ntype supportedTypes = boolean | string | number | Date | Uint8Array | bigint;\n\ntype serializedType = {\n  value: supportedTypes;\n  type?: string;\n};\n\nfunction serializePrimitive(value: any): serializedType {\n  const serializedValue: serializedType = { value };\n  if (\n    value === undefined ||\n    value === null ||\n    typeof value === \"boolean\" ||\n    typeof value === \"string\" ||\n    typeof value === \"number\"\n  ) {\n    serializedValue.value = value;\n  } else if (typeof value === \"bigint\") {\n    serializedValue.value = value.toString();\n    serializedValue.type = Edm.Int64;\n  } else if (value instanceof Date) {\n    serializedValue.value = value;\n    serializedValue.type = Edm.DateTime;\n  } else if (value instanceof Uint8Array) {\n    serializedValue.value = base64Encode(value);\n    serializedValue.type = Edm.Binary;\n  } else {\n    throw new Error(`Unknown EDM type ${typeof value}`);\n  }\n\n  return serializedValue;\n}\n\nfunction serializeObject(obj: { value: any; type: EdmTypes }): serializedType {\n  const serializedValue: serializedType = { value: obj.value };\n  if (\n    obj.type === \"Boolean\" ||\n    obj.type === \"DateTime\" ||\n    obj.type === \"Double\" ||\n    obj.type === \"Guid\" ||\n    obj.type === \"Int32\" ||\n    obj.type === \"Int64\" ||\n    obj.type === \"String\" ||\n    obj.type === \"Binary\"\n  ) {\n    serializedValue.value = obj.value;\n    serializedValue.type = Edm[obj.type];\n  } else {\n    throw new Error(`Unknown EDM type ${typeof obj.value}`);\n  }\n\n  return serializedValue;\n}\n\nfunction getSerializedValue(value: any): serializedType {\n  if (typeof value === \"object\" && value?.value !== undefined && value?.type !== undefined) {\n    return serializeObject(value);\n  } else {\n    return serializePrimitive(value);\n  }\n}\n\nfunction translatePropertyNameForSerialization(propertyName: string): string {\n  for (const [original, internal] of propertyCaseMap) {\n    if (internal === propertyName) {\n      return original;\n    }\n  }\n\n  return propertyName;\n}\n\nexport function serialize(obj: object): Record<string, Record<string, unknown>> {\n  const serialized: any = {};\n  for (const [propertyName, propertyValue] of Object.entries(obj)) {\n    const transformedKey = translatePropertyNameForSerialization(propertyName);\n    const serializedVal = getSerializedValue(propertyValue);\n    serialized[transformedKey] = serializedVal.value;\n    if (serializedVal.type) {\n      serialized[`${transformedKey}@odata.type`] = serializedVal.type;\n    }\n  }\n  return serialized;\n}\n\nfunction getTypedObject(value: any, type: string, disableTypeConversion: boolean): any {\n  switch (type) {\n    case Edm.Boolean:\n      return disableTypeConversion ? { value, type: \"Boolean\" } : value;\n    case Edm.Double:\n      return disableTypeConversion ? { value, type: \"Double\" } : value;\n    case Edm.Int32:\n      return disableTypeConversion ? { value, type: \"Int32\" } : value;\n    case Edm.String:\n      return disableTypeConversion ? { value, type: \"String\" } : value;\n    case Edm.DateTime:\n      return disableTypeConversion ? { value, type: \"DateTime\" } : new Date(value);\n    case Edm.Int64:\n      return disableTypeConversion ? { value, type: \"Int64\" } : BigInt(value);\n    case Edm.Guid:\n      return { value, type: \"Guid\" };\n    case Edm.Binary:\n      return disableTypeConversion ? { value, type: \"Binary\" } : base64Decode(value);\n    default:\n      throw new Error(`Unknown EDM type ${type}`);\n  }\n}\n\nexport function deserialize<T extends object = Record<string, any>>(\n  obj: object,\n  disableTypeConversion: boolean = false\n): T {\n  const deserialized: any = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key.indexOf(\"@odata.type\") === -1) {\n      const transformedKey = propertyCaseMap.get(key) ?? key;\n      let typedValue = value;\n      if (`${key}@odata.type` in obj) {\n        const type = (obj as any)[`${key}@odata.type`];\n        typedValue = getTypedObject(value, type, disableTypeConversion);\n      } else if (disableTypeConversion && [\"number\", \"string\", \"boolean\"].includes(typeof value)) {\n        // The service, doesn't return type metadata for number, strings or booleans\n        // if automatic type conversion is disabled we'll infer the EDM object\n        typedValue = inferTypedObject(key, value);\n      }\n\n      deserialized[transformedKey] = typedValue;\n    }\n  }\n  return deserialized;\n}\n\nfunction inferTypedObject(propertyName: string, value: number | string | boolean) {\n  // We need to skip service metadata fields such as partitionKey and rowKey and use the same value returned by the service\n  if (propertyCaseMap.has(propertyName)) {\n    return value;\n  }\n\n  switch (typeof value) {\n    case \"boolean\":\n      return { value: String(value), type: \"Boolean\" };\n    case \"number\":\n      return getTypedNumber(value);\n    case \"string\":\n      return { value, type: \"String\" };\n    default:\n      return value;\n  }\n}\n\n/**\n * Returns the number when typeConversion is enabled or the EDM object with the correct number format Double or Int32 if disabled\n */\nfunction getTypedNumber(value: number): { value: string; type: \"Int32\" | \"Double\" } {\n  const valueStr = String(value);\n  if (Number.isSafeInteger(value)) {\n    return { value: valueStr, type: \"Int32\" };\n  } else {\n    return { value: valueStr, type: \"Double\" };\n  }\n}\n\nexport function deserializeObjectsArray<T extends object>(\n  objArray: object[],\n  disableTypeConversion: boolean\n): T[] {\n  return objArray.map((obj) => deserialize<T>(obj, disableTypeConversion));\n}\n\n/**\n * For ACL endpoints the Tables Service takes an ISO Date without decimals however\n * serializing a JavaScript date gives us a date with decimals 2021-07-08T09:10:09.000Z\n * which makes the XML request body invalid, these 2 functions serialize and deserialize the\n * dates so that they are in the expected format\n */\nexport function serializeSignedIdentifiers(\n  signedIdentifiers: SignedIdentifier[]\n): GeneratedSignedIdentifier[] {\n  return signedIdentifiers.map((acl) => {\n    const { id, accessPolicy } = acl;\n    const { start, expiry, ...rest } = accessPolicy ?? {};\n    const serializedStart = start\n      ? truncatedISO8061Date(start, false /** withMilliseconds */)\n      : undefined;\n    const serializedExpiry = expiry\n      ? truncatedISO8061Date(expiry, false /** withMilliseconds */)\n      : undefined;\n\n    return {\n      id,\n      accessPolicy: {\n        ...(serializedExpiry && { expiry: serializedExpiry }),\n        ...(serializedStart && { start: serializedStart }),\n        ...rest,\n      },\n    };\n  });\n}\n\nexport function deserializeSignedIdentifier(\n  signedIdentifiers: GeneratedSignedIdentifier[]\n): SignedIdentifier[] {\n  return signedIdentifiers.map((si) => {\n    const { id, accessPolicy } = si;\n    const { start, expiry, ...restAcl } = accessPolicy ?? {};\n    const deserializedStart = start ? new Date(start) : undefined;\n    const deserializedExpiry = expiry ? new Date(expiry) : undefined;\n\n    return {\n      id,\n      accessPolicy: {\n        ...(deserializedExpiry && { expiry: deserializedExpiry }),\n        ...(deserializedStart && { start: deserializedStart }),\n        ...restAcl,\n      },\n    };\n  });\n}\n\nexport function serializeQueryOptions(query: TableEntityQueryOptions): GeneratedQueryOptions {\n  const { select, ...queryOptions } = query;\n  const mappedQuery: GeneratedQueryOptions = { ...queryOptions };\n  // Properties that are always returned by the service but are not allowed in select\n  const excludeFromSelect = [\"etag\", \"odata.etag\"];\n  if (select) {\n    mappedQuery.select = select\n      .filter((p) => !excludeFromSelect.includes(p))\n      .map(translatePropertyNameForSerialization)\n      .join(\",\");\n  }\n  return mappedQuery;\n}\n"]}