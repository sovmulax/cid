/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure App Configuration SDK for JavaScript - 1.3.1
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var crypto = require('crypto');
var abortController = require('@azure/abort-controller');
require('@azure/core-asynciterator-polyfill');
var coreTracing = require('@azure/core-tracing');

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
async function sha256Digest(body) {
    return crypto.createHash("sha256")
        .update(body || "")
        .digest("base64");
}
/**
 * @internal
 */
async function sha256Hmac(secret, stringToSign) {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret)
        .update(stringToSign)
        .digest("base64");
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
class AppConfigCredential {
    constructor(credential, secret) {
        this.credential = credential;
        this.secret = secret;
    }
    /**
     * Signs a request with the values provided in the credential and secret parameter.
     *
     * @param webResource - The WebResource to be signed.
     * @returns The signed request object.
     */
    async signRequest(webResource) {
        const verb = webResource.method.toUpperCase();
        const utcNow = new Date().toUTCString();
        const contentHash = await sha256Digest(webResource.body || "");
        const signedHeaders = "x-ms-date;host;x-ms-content-sha256";
        const url = coreHttp.URLBuilder.parse(webResource.url);
        const query = url.getQuery();
        const urlPathAndQuery = `${url.getPath()}${query ? "?" + query : ""}`;
        const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${url.getHost()};${contentHash}`;
        const signature = await sha256Hmac(this.secret, stringToSign);
        webResource.headers.set("x-ms-date", utcNow);
        webResource.headers.set("x-ms-content-sha256", contentHash);
        // Syntax for Authorization header
        // Reference - https://docs.microsoft.com/en-us/azure/azure-app-configuration/rest-api-authentication-hmac#syntax
        webResource.headers.set("Authorization", `HMAC-SHA256 Credential=${this.credential}&SignedHeaders=${signedHeaders}&Signature=${signature}`);
        return webResource;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const KeyListResult = {
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Key"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Key = {
    type: {
        name: "Composite",
        className: "Key",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KeyValueListResult = {
    type: {
        name: "Composite",
        className: "KeyValueListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValue"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyValue = {
    type: {
        name: "Composite",
        className: "KeyValue",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content_type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last_modified",
                type: {
                    name: "DateTime"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            locked: {
                serializedName: "locked",
                type: {
                    name: "Boolean"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabelListResult = {
    type: {
        name: "Composite",
        className: "LabelListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Label"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Label = {
    type: {
        name: "Composite",
        className: "Label",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetKeysHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetKeysHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationCheckKeysHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationCheckKeysHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetKeyValuesHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetKeyValuesHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationCheckKeyValuesHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationCheckKeyValuesHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetKeyValueHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationPutKeyValueHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationPutKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationDeleteKeyValueHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationDeleteKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationCheckKeyValueHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationCheckKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetLabelsHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetLabelsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationCheckLabelsHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationCheckLabelsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationPutLockHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationPutLockHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationDeleteLockHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationDeleteLockHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetRevisionsHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetRevisionsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationCheckRevisionsHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationCheckRevisionsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetKeysNextHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetKeysNextHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetKeyValuesNextHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetKeyValuesNextHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetLabelsNextHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetLabelsNextHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppConfigurationGetRevisionsNextHeaders = {
    type: {
        name: "Composite",
        className: "AppConfigurationGetRevisionsNextHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    KeyListResult: KeyListResult,
    Key: Key,
    ErrorModel: ErrorModel,
    KeyValueListResult: KeyValueListResult,
    KeyValue: KeyValue,
    LabelListResult: LabelListResult,
    Label: Label,
    AppConfigurationGetKeysHeaders: AppConfigurationGetKeysHeaders,
    AppConfigurationCheckKeysHeaders: AppConfigurationCheckKeysHeaders,
    AppConfigurationGetKeyValuesHeaders: AppConfigurationGetKeyValuesHeaders,
    AppConfigurationCheckKeyValuesHeaders: AppConfigurationCheckKeyValuesHeaders,
    AppConfigurationGetKeyValueHeaders: AppConfigurationGetKeyValueHeaders,
    AppConfigurationPutKeyValueHeaders: AppConfigurationPutKeyValueHeaders,
    AppConfigurationDeleteKeyValueHeaders: AppConfigurationDeleteKeyValueHeaders,
    AppConfigurationCheckKeyValueHeaders: AppConfigurationCheckKeyValueHeaders,
    AppConfigurationGetLabelsHeaders: AppConfigurationGetLabelsHeaders,
    AppConfigurationCheckLabelsHeaders: AppConfigurationCheckLabelsHeaders,
    AppConfigurationPutLockHeaders: AppConfigurationPutLockHeaders,
    AppConfigurationDeleteLockHeaders: AppConfigurationDeleteLockHeaders,
    AppConfigurationGetRevisionsHeaders: AppConfigurationGetRevisionsHeaders,
    AppConfigurationCheckRevisionsHeaders: AppConfigurationCheckRevisionsHeaders,
    AppConfigurationGetKeysNextHeaders: AppConfigurationGetKeysNextHeaders,
    AppConfigurationGetKeyValuesNextHeaders: AppConfigurationGetKeyValuesNextHeaders,
    AppConfigurationGetLabelsNextHeaders: AppConfigurationGetLabelsNextHeaders,
    AppConfigurationGetRevisionsNextHeaders: AppConfigurationGetRevisionsNextHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/vnd.microsoft.appconfig.keyset+json, application/json, application/problem+json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const name = {
    parameterPath: ["options", "name"],
    mapper: {
        serializedName: "name",
        type: {
            name: "String"
        }
    }
};
const syncToken = {
    parameterPath: "syncToken",
    mapper: {
        serializedName: "Sync-Token",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const after = {
    parameterPath: ["options", "after"],
    mapper: {
        serializedName: "After",
        type: {
            name: "String"
        }
    }
};
const acceptDatetime = {
    parameterPath: ["options", "acceptDatetime"],
    mapper: {
        serializedName: "Accept-Datetime",
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/vnd.microsoft.appconfig.kvset+json, application/json, application/problem+json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const key = {
    parameterPath: ["options", "key"],
    mapper: {
        serializedName: "key",
        type: {
            name: "String"
        }
    }
};
const label = {
    parameterPath: ["options", "label"],
    mapper: {
        serializedName: "label",
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const select1 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/vnd.microsoft.appconfig.kv+json, application/json, application/problem+json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const key1 = {
    parameterPath: "key",
    mapper: {
        serializedName: "key",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const select2 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/vnd.microsoft.appconfig.kv+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const entity = {
    parameterPath: ["options", "entity"],
    mapper: KeyValue
};
const select3 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/vnd.microsoft.appconfig.labelset+json, application/json, application/problem+json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const select4 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                defaultValue: "name",
                isConstant: true,
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const select5 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const select6 = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "app-configuration";
const packageVersion = "1.3.1";
/** @internal */
class AppConfigurationContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the AppConfigurationContext class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param endpoint The endpoint of the App Configuration instance to send requests to.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(credentials, endpoint, apiVersion, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(credentials, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        this.apiVersion = apiVersion;
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class AppConfiguration extends AppConfigurationContext {
    /**
     * Initializes a new instance of the AppConfiguration class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param endpoint The endpoint of the App Configuration instance to send requests to.
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(credentials, endpoint, apiVersion, options) {
        super(credentials, endpoint, apiVersion, options);
    }
    /**
     * Gets a list of keys.
     * @param options The options parameters.
     */
    getKeys(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getKeysOperationSpec);
    }
    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkKeys(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, checkKeysOperationSpec);
    }
    /**
     * Gets a list of key-values.
     * @param options The options parameters.
     */
    getKeyValues(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getKeyValuesOperationSpec);
    }
    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkKeyValues(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, checkKeyValuesOperationSpec);
    }
    /**
     * Gets a single key-value.
     * @param key The key of the key-value to retrieve.
     * @param options The options parameters.
     */
    getKeyValue(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getKeyValueOperationSpec);
    }
    /**
     * Creates a key-value.
     * @param key The key of the key-value to create.
     * @param options The options parameters.
     */
    putKeyValue(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, putKeyValueOperationSpec);
    }
    /**
     * Deletes a key-value.
     * @param key The key of the key-value to delete.
     * @param options The options parameters.
     */
    deleteKeyValue(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteKeyValueOperationSpec);
    }
    /**
     * Requests the headers and status of the given resource.
     * @param key The key of the key-value to retrieve.
     * @param options The options parameters.
     */
    checkKeyValue(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, checkKeyValueOperationSpec);
    }
    /**
     * Gets a list of labels.
     * @param options The options parameters.
     */
    getLabels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getLabelsOperationSpec);
    }
    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkLabels(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, checkLabelsOperationSpec);
    }
    /**
     * Locks a key-value.
     * @param key The key of the key-value to lock.
     * @param options The options parameters.
     */
    putLock(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, putLockOperationSpec);
    }
    /**
     * Unlocks a key-value.
     * @param key The key of the key-value to unlock.
     * @param options The options parameters.
     */
    deleteLock(key, options) {
        const operationArguments = {
            key,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, deleteLockOperationSpec);
    }
    /**
     * Gets a list of key-value revisions.
     * @param options The options parameters.
     */
    getRevisions(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getRevisionsOperationSpec);
    }
    /**
     * Requests the headers and status of the given resource.
     * @param options The options parameters.
     */
    checkRevisions(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, checkRevisionsOperationSpec);
    }
    /**
     * GetKeysNext
     * @param nextLink The nextLink from the previous successful call to the GetKeys method.
     * @param options The options parameters.
     */
    getKeysNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getKeysNextOperationSpec);
    }
    /**
     * GetKeyValuesNext
     * @param nextLink The nextLink from the previous successful call to the GetKeyValues method.
     * @param options The options parameters.
     */
    getKeyValuesNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getKeyValuesNextOperationSpec);
    }
    /**
     * GetLabelsNext
     * @param nextLink The nextLink from the previous successful call to the GetLabels method.
     * @param options The options parameters.
     */
    getLabelsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getLabelsNextOperationSpec);
    }
    /**
     * GetRevisionsNext
     * @param nextLink The nextLink from the previous successful call to the GetRevisions method.
     * @param options The options parameters.
     */
    getRevisionsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.sendOperationRequest(operationArguments, getRevisionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const getKeysOperationSpec = {
    path: "/keys",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult,
            headersMapper: AppConfigurationGetKeysHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [name, apiVersion, after],
    urlParameters: [endpoint],
    headerParameters: [
        accept,
        syncToken,
        acceptDatetime
    ],
    serializer
};
const checkKeysOperationSpec = {
    path: "/keys",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AppConfigurationCheckKeysHeaders
        },
        default: {}
    },
    queryParameters: [name, apiVersion, after],
    urlParameters: [endpoint],
    headerParameters: [syncToken, acceptDatetime],
    serializer
};
const getKeyValuesOperationSpec = {
    path: "/kv",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: AppConfigurationGetKeyValuesHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select
    ],
    urlParameters: [endpoint],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept1
    ],
    serializer
};
const checkKeyValuesOperationSpec = {
    path: "/kv",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AppConfigurationCheckKeyValuesHeaders
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select1
    ],
    urlParameters: [endpoint],
    headerParameters: [syncToken, acceptDatetime],
    serializer
};
const getKeyValueOperationSpec = {
    path: "/kv/{key}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: AppConfigurationGetKeyValueHeaders
        },
        304: {
            headersMapper: AppConfigurationGetKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        apiVersion,
        label,
        select2
    ],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept2,
        ifMatch,
        ifNoneMatch
    ],
    serializer
};
const putKeyValueOperationSpec = {
    path: "/kv/{key}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: AppConfigurationPutKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: entity,
    queryParameters: [apiVersion, label],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        accept2,
        ifMatch,
        ifNoneMatch,
        contentType
    ],
    mediaType: "json",
    serializer
};
const deleteKeyValueOperationSpec = {
    path: "/kv/{key}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: AppConfigurationDeleteKeyValueHeaders
        },
        204: {
            headersMapper: AppConfigurationDeleteKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, label],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        accept2,
        ifMatch
    ],
    serializer
};
const checkKeyValueOperationSpec = {
    path: "/kv/{key}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AppConfigurationCheckKeyValueHeaders
        },
        304: {
            headersMapper: AppConfigurationCheckKeyValueHeaders
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        label,
        select3
    ],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        acceptDatetime,
        ifMatch,
        ifNoneMatch
    ],
    serializer
};
const getLabelsOperationSpec = {
    path: "/labels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabelListResult,
            headersMapper: AppConfigurationGetLabelsHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        name,
        apiVersion,
        after,
        select4
    ],
    urlParameters: [endpoint],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept3
    ],
    serializer
};
const checkLabelsOperationSpec = {
    path: "/labels",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AppConfigurationCheckLabelsHeaders
        },
        default: {}
    },
    queryParameters: [
        name,
        apiVersion,
        after,
        select4
    ],
    urlParameters: [endpoint],
    headerParameters: [syncToken, acceptDatetime],
    serializer
};
const putLockOperationSpec = {
    path: "/locks/{key}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: AppConfigurationPutLockHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, label],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        accept2,
        ifMatch,
        ifNoneMatch
    ],
    serializer
};
const deleteLockOperationSpec = {
    path: "/locks/{key}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: AppConfigurationDeleteLockHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, label],
    urlParameters: [endpoint, key1],
    headerParameters: [
        syncToken,
        accept2,
        ifMatch,
        ifNoneMatch
    ],
    serializer
};
const getRevisionsOperationSpec = {
    path: "/revisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: AppConfigurationGetRevisionsHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select5
    ],
    urlParameters: [endpoint],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept1
    ],
    serializer
};
const checkRevisionsOperationSpec = {
    path: "/revisions",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: AppConfigurationCheckRevisionsHeaders
        },
        default: {}
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select6
    ],
    urlParameters: [endpoint],
    headerParameters: [syncToken, acceptDatetime],
    serializer
};
const getKeysNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyListResult,
            headersMapper: AppConfigurationGetKeysNextHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [name, apiVersion, after],
    urlParameters: [endpoint, nextLink],
    headerParameters: [
        accept,
        syncToken,
        acceptDatetime
    ],
    serializer
};
const getKeyValuesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: AppConfigurationGetKeyValuesNextHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select
    ],
    urlParameters: [endpoint, nextLink],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept1
    ],
    serializer
};
const getLabelsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabelListResult,
            headersMapper: AppConfigurationGetLabelsNextHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        name,
        apiVersion,
        after,
        select4
    ],
    urlParameters: [endpoint, nextLink],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept3
    ],
    serializer
};
const getRevisionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: AppConfigurationGetRevisionsNextHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [
        apiVersion,
        after,
        key,
        label,
        select5
    ],
    urlParameters: [endpoint, nextLink],
    headerParameters: [
        syncToken,
        acceptDatetime,
        accept1
    ],
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 */
function throttlingRetryPolicy(retryOptions) {
    return {
        create: (nextPolicy, options) => {
            return new ThrottlingRetryPolicy(nextPolicy, options, retryOptions);
        }
    };
}
const StandardAbortMessage = "The operation was aborted.";
// Merge this constant with the one in core-http when we unify throttling retry policy in core-http and app-config
const DEFAULT_CLIENT_RETRY_COUNT = 3;
/**
 * This policy is a close copy of the ThrottlingRetryPolicy class from
 * core-http with modifications to work with how AppConfig is currently
 * responding to 429 responses (which is to throw a RestError).
 *
 * @internal
 */
class ThrottlingRetryPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, retryOptions = { maxRetries: DEFAULT_CLIENT_RETRY_COUNT }) {
        super(nextPolicy, options);
        this.retryOptions = retryOptions;
        this.numberOfRetries = 0;
    }
    async sendRequest(httpRequest) {
        return this._nextPolicy.sendRequest(httpRequest.clone()).catch(async (err) => {
            var _a;
            if (isRestErrorWithHeaders(err)) {
                let delayInMs = getDelayInMs(err.response.headers);
                if (delayInMs == null) {
                    throw err;
                }
                if (this.retryOptions.maxRetryDelayInMs &&
                    delayInMs > this.retryOptions.maxRetryDelayInMs) {
                    delayInMs = this.retryOptions.maxRetryDelayInMs;
                }
                this.numberOfRetries += 1;
                await coreHttp.delay(delayInMs, undefined, {
                    abortSignal: httpRequest.abortSignal,
                    abortErrorMsg: StandardAbortMessage
                });
                if ((_a = httpRequest.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {
                    throw new abortController.AbortError(StandardAbortMessage);
                }
                if (this.retryOptions.maxRetries === undefined || this.retryOptions.maxRetries === null) {
                    this.retryOptions.maxRetries = DEFAULT_CLIENT_RETRY_COUNT;
                }
                if (this.numberOfRetries < this.retryOptions.maxRetries) {
                    // retries
                    return this.sendRequest(httpRequest.clone());
                }
                else {
                    // passes on to the next policy
                    return this._nextPolicy.sendRequest(httpRequest.clone());
                }
            }
            else {
                throw err;
            }
        });
    }
    static parseRetryAfterHeader(headerValue) {
        const retryAfterInSeconds = Number(headerValue);
        if (Number.isNaN(retryAfterInSeconds)) {
            return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
        }
        else {
            return retryAfterInSeconds * 1000;
        }
    }
    static parseDateRetryAfterHeader(headerValue) {
        try {
            const now = Date.now();
            const date = Date.parse(headerValue);
            const diff = date - now;
            return Number.isNaN(diff) ? undefined : diff;
        }
        catch (error) {
            return undefined;
        }
    }
}
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry (in milliseconds).
 */
const RetryAfterMillisecondsHeaders = ["retry-after-ms", "x-ms-retry-after-ms"];
/**
 * Extracts the retry response header, checking against several
 * header names.
 * @internal
 */
function getDelayInMs(responseHeaders) {
    for (const name of RetryAfterMillisecondsHeaders) {
        const delayValueString = responseHeaders.get(name);
        if (delayValueString == null) {
            continue;
        }
        const delayValueMs = Number(delayValueString);
        if (Number.isNaN(delayValueMs)) {
            return undefined;
        }
        return delayValueMs;
    }
    const retryAfterValue = responseHeaders.get(coreHttp.Constants.HeaderConstants.RETRY_AFTER);
    if (retryAfterValue != null) {
        return ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterValue);
    }
    return undefined;
}
function isRestErrorWithHeaders(err) {
    return (err &&
        err.statusCode &&
        typeof err.statusCode === "number" &&
        err.response &&
        err.response.headers &&
        typeof err.response.headers.get === "function");
}

// Copyright (c) Microsoft Corporation.
/**
 * The prefix for feature flags.
 */
const featureFlagPrefix = ".appconfig.featureflag/";
/**
 * The content type for a FeatureFlag
 */
const featureFlagContentType = "application/vnd.microsoft.appconfig.ff+json;charset=utf-8";
/**
 * @internal
 */
const FeatureFlagHelper = {
    /**
     * Takes the FeatureFlag (JSON) and returns a ConfigurationSetting (with the props encodeed in the value).
     */
    toConfigurationSettingParam: (featureFlag) => {
        var _a;
        if (!featureFlag.value) {
            throw new TypeError(`FeatureFlag has an unexpected value - ${featureFlag.value}`);
        }
        let key = featureFlag.key;
        if (typeof featureFlag.key === "string" && !featureFlag.key.startsWith(featureFlagPrefix)) {
            key = featureFlagPrefix + featureFlag.key;
        }
        const jsonFeatureFlagValue = {
            id: (_a = featureFlag.value.id) !== null && _a !== void 0 ? _a : key.replace(featureFlagPrefix, ""),
            enabled: featureFlag.value.enabled,
            description: featureFlag.value.description,
            conditions: {
                client_filters: featureFlag.value.conditions.clientFilters
            },
            display_name: featureFlag.value.displayName
        };
        const configSetting = Object.assign(Object.assign({}, featureFlag), { key, value: JSON.stringify(jsonFeatureFlagValue) });
        return configSetting;
    }
};
/**
 * Takes the ConfigurationSetting as input and returns the ConfigurationSetting<FeatureFlagValue> by parsing the value string.
 */
function parseFeatureFlag(setting) {
    if (!isFeatureFlag(setting)) {
        throw TypeError(errorMessageForUnexpectedSetting(setting.key, "FeatureFlag"));
    }
    const jsonFeatureFlagValue = JSON.parse(setting.value);
    let key = setting.key;
    if (typeof setting.key === "string" && !setting.key.startsWith(featureFlagPrefix)) {
        key = featureFlagPrefix + setting.key;
    }
    const featureflag = Object.assign(Object.assign({}, setting), { value: {
            id: jsonFeatureFlagValue.id,
            enabled: jsonFeatureFlagValue.enabled,
            description: jsonFeatureFlagValue.description,
            displayName: jsonFeatureFlagValue.display_name,
            conditions: { clientFilters: jsonFeatureFlagValue.conditions.client_filters }
        }, key, contentType: featureFlagContentType });
    return featureflag;
}
/**
 * Lets you know if the ConfigurationSetting is a feature flag.
 *
 * [Checks if the content type is featureFlagContentType `"application/vnd.microsoft.appconfig.ff+json;charset=utf-8"`]
 */
function isFeatureFlag(setting) {
    return (setting && setting.contentType === featureFlagContentType && typeof setting.value === "string");
}

// Copyright (c) Microsoft Corporation.
/**
 * content-type for the secret reference.
 */
const secretReferenceContentType = "application/vnd.microsoft.appconfig.keyvaultref+json;charset=utf-8";
/**
 * @internal
 */
const SecretReferenceHelper = {
    /**
     * Takes the SecretReference (JSON) and returns a ConfigurationSetting (with the props encodeed in the value).
     */
    toConfigurationSettingParam: (secretReference) => {
        if (!secretReference.value) {
            throw new TypeError(`SecretReference has an unexpected value - ${secretReference.value}`);
        }
        const jsonSecretReferenceValue = {
            uri: secretReference.value.secretId
        };
        const configSetting = Object.assign(Object.assign({}, secretReference), { value: JSON.stringify(jsonSecretReferenceValue) });
        return configSetting;
    }
};
/**
 * Takes the ConfigurationSetting as input and returns the ConfigurationSetting<SecretReferenceValue> by parsing the value string.
 */
function parseSecretReference(setting) {
    if (!isSecretReference(setting)) {
        throw TypeError(errorMessageForUnexpectedSetting(setting.key, "SecretReference"));
    }
    const jsonSecretReferenceValue = JSON.parse(setting.value);
    const secretReference = Object.assign(Object.assign({}, setting), { value: { secretId: jsonSecretReferenceValue.uri } });
    return secretReference;
}
/**
 * Lets you know if the ConfigurationSetting is a secret reference.
 *
 * [Checks if the content type is secretReferenceContentType `"application/vnd.microsoft.appconfig.keyvaultref+json;charset=utf-8"`]
 */
function isSecretReference(setting) {
    return (setting &&
        setting.contentType === secretReferenceContentType &&
        typeof setting.value === "string");
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 * @internal
 */
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}

// Copyright (c) Microsoft Corporation.
/**
 * Formats the etag so it can be used with a If-Match/If-None-Match header
 * @internal
 */
function quoteETag(etag) {
    // https://tools.ietf.org/html/rfc7232#section-3.1
    if (etag === undefined || etag === "*") {
        return etag;
    }
    if (etag.startsWith('"') && etag.endsWith('"')) {
        return etag;
    }
    if (etag.startsWith("'") && etag.endsWith("'")) {
        return etag;
    }
    return `"${etag}"`;
}
/**
 * Checks the onlyIfChanged/onlyIfUnchanged properties to make sure we haven't specified both
 * and throws an Error. Otherwise, returns the properties properly quoted.
 * @param options - An options object with onlyIfChanged/onlyIfUnchanged fields
 * @internal
 */
function checkAndFormatIfAndIfNoneMatch(configurationSetting, options) {
    if (options.onlyIfChanged && options.onlyIfUnchanged) {
        throw new Error("onlyIfChanged and onlyIfUnchanged are mutually-exclusive");
    }
    let ifMatch;
    let ifNoneMatch;
    if (options.onlyIfUnchanged) {
        ifMatch = quoteETag(configurationSetting.etag);
    }
    if (options.onlyIfChanged) {
        ifNoneMatch = quoteETag(configurationSetting.etag);
    }
    return {
        ifMatch: ifMatch,
        ifNoneMatch: ifNoneMatch
    };
}
/**
 * Transforms some of the key fields in ListConfigurationSettingsOptions and ListRevisionsOptions
 * so they can be added to a request using AppConfigurationGetKeyValuesOptionalParams.
 * - `options.acceptDateTime` is converted into an ISO string
 * - `select` is populated with the proper field names from `options.fields`
 * - keyFilter and labelFilter are moved to key and label, respectively.
 *
 * @internal
 */
function formatFiltersAndSelect(listConfigOptions) {
    let acceptDatetime = undefined;
    if (listConfigOptions.acceptDateTime) {
        acceptDatetime = listConfigOptions.acceptDateTime.toISOString();
    }
    return {
        key: listConfigOptions.keyFilter,
        label: listConfigOptions.labelFilter,
        acceptDatetime,
        select: formatFieldsForSelect(listConfigOptions.fields)
    };
}
/**
 * Handles translating a Date acceptDateTime into a string as needed by the API
 * @param newOptions - A newer style options with acceptDateTime as a date (and with proper casing!)
 * @internal
 */
function formatAcceptDateTime(newOptions) {
    return {
        acceptDatetime: newOptions.acceptDateTime && newOptions.acceptDateTime.toISOString()
    };
}
/**
 * Take the URL that gets returned from next link and extract the 'after' token needed
 * to get the next page of results.
 * @internal
 */
function extractAfterTokenFromNextLink(nextLink) {
    const parsedLink = coreHttp.URLBuilder.parse(nextLink);
    const afterToken = parsedLink.getQueryParameterValue("after");
    if (afterToken == null || Array.isArray(afterToken)) {
        throw new Error("Invalid nextLink - invalid after token");
    }
    return decodeURIComponent(afterToken);
}
/**
 * Makes a ConfigurationSetting-based response throw for all of the data members. Used primarily
 * to prevent possible errors by the user in accessing a model that is uninitialized. This can happen
 * in cases like HTTP status code 204 or 304, which return an empty response body.
 *
 * @param configurationSetting - The configuration setting to alter
 */
function makeConfigurationSettingEmpty(configurationSetting) {
    const names = [
        "contentType",
        "etag",
        "label",
        "lastModified",
        "isReadOnly",
        "tags",
        "value"
    ];
    for (const name of names) {
        configurationSetting[name] = undefined;
    }
}
/**
 * @internal
 */
function transformKeyValue(kvp) {
    const setting = Object.assign(Object.assign({ value: undefined }, kvp), { isReadOnly: !!kvp.locked });
    delete setting.locked;
    return setting;
}
/**
 * @internal
 */
function isConfigSettingWithSecretReferenceValue(setting) {
    return (setting.contentType === secretReferenceContentType &&
        isDefined(setting.value) &&
        typeof setting.value !== "string");
}
/**
 * @internal
 */
function isConfigSettingWithFeatureFlagValue(setting) {
    return (setting.contentType === featureFlagContentType &&
        isDefined(setting.value) &&
        typeof setting.value !== "string");
}
/**
 * @internal
 */
function isSimpleConfigSetting(setting) {
    return typeof setting.value === "string" || !isDefined(setting.value);
}
/**
 * @internal
 */
function serializeAsConfigurationSettingParam(setting) {
    if (isSimpleConfigSetting(setting)) {
        return setting;
    }
    try {
        if (isConfigSettingWithFeatureFlagValue(setting)) {
            return FeatureFlagHelper.toConfigurationSettingParam(setting);
        }
        if (isConfigSettingWithSecretReferenceValue(setting)) {
            return SecretReferenceHelper.toConfigurationSettingParam(setting);
        }
    }
    catch (error) {
        return setting;
    }
    throw new TypeError(`Unable to serialize the setting with key "${setting.key}" as a configuration setting`);
}
/**
 * @internal
 */
function transformKeyValueResponseWithStatusCode(kvp) {
    return normalizeResponse(kvp, Object.assign(Object.assign({}, transformKeyValue(kvp)), { statusCode: kvp._response.status }));
}
/**
 * @internal
 */
function transformKeyValueResponse(kvp) {
    return normalizeResponse(kvp, Object.assign({}, transformKeyValue(kvp)));
}
function normalizeResponse(originalResponse, newResponse) {
    Object.defineProperty(newResponse, "_response", {
        enumerable: false,
        value: originalResponse._response
    });
    // this field comes from the header but it's redundant with
    // the one serialized in the model itself
    delete newResponse.eTag;
    return newResponse;
}
/**
 * Translates user-facing field names into their `select` equivalents (these can be
 * seen in the `KnownEnum5`)
 *
 * @param fieldNames - fieldNames from users.
 * @returns The field names translated into the `select` field equivalents.
 *
 * @internal
 */
function formatFieldsForSelect(fieldNames) {
    if (fieldNames == null) {
        return undefined;
    }
    const mappedFieldNames = fieldNames.map((fn) => {
        switch (fn) {
            case "lastModified":
                return "last_modified";
            case "contentType":
                return "content_type";
            case "isReadOnly":
                return "locked";
            default:
                return fn;
        }
    });
    return mappedFieldNames;
}
/**
 * @internal
 */
function errorMessageForUnexpectedSetting(key, expectedType) {
    return `Setting with key ${key} is not a valid ${expectedType}, make sure to have the correct content-type and a valid non-null value.`;
}

// Copyright (c) Microsoft Corporation.
/** @internal */
const createSpan = coreTracing.createSpanFunction({
    namespace: "Microsoft.AppConfiguration",
    packagePrefix: "Azure.Data.AppConfiguration"
});
/**
 * Traces an operation and properly handles reporting start, end and errors for a given span
 *
 * @param operationName - Name of a method in the TClient type
 * @param options - An options class, typically derived from \@azure/core-http/RequestOptionsBase
 * @param fn - The function to call with an options class that properly propagates the span context
 *
 * @internal
 */
async function trace(operationName, options, fn, createSpanFn = createSpan) {
    const { updatedOptions, span } = createSpanFn(operationName, options);
    try {
        // NOTE: we really do need to await on this function here so we can handle any exceptions thrown and properly
        // close the span.
        const result = await fn(updatedOptions, span);
        span.setStatus({
            code: coreTracing.SpanStatusCode.OK
        });
        return result;
    }
    catch (err) {
        span.setStatus({
            code: coreTracing.SpanStatusCode.ERROR,
            message: err.message
        });
        throw err;
    }
    finally {
        span.end();
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The sync token header, as described here:
 * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency
 * @internal
 */
const SyncTokenHeaderName = "sync-token";
/**
 * A policy factory for injecting sync tokens properly into outgoing requests.
 * @param syncTokens - the sync tokens store to be used across requests.
 * @internal
 */
function syncTokenPolicy(syncTokens) {
    return {
        create: (nextPolicy, options) => {
            return new SyncTokenPolicy(nextPolicy, options, syncTokens);
        }
    };
}
class SyncTokenPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, _syncTokens) {
        super(nextPolicy, options);
        this._syncTokens = _syncTokens;
    }
    async sendRequest(webResource) {
        const syncTokenHeaderValue = this._syncTokens.getSyncTokenHeaderValue();
        if (syncTokenHeaderValue != null) {
            webResource.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);
        }
        const response = await this._nextPolicy.sendRequest(webResource);
        this._syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));
        return response;
    }
}
/**
 * Sync token tracker (allows for real-time consistency, even in the face of
 * caching and load balancing within App Configuration).
 *
 * (protocol and format described here)
 * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency
 *
 * @internal
 */
class SyncTokens {
    constructor() {
        this._currentSyncTokens = new Map();
    }
    /**
     * Takes the value from the header named after the constant `SyncTokenHeaderName`
     * and adds it to our list of accumulated sync tokens.
     *
     * If given an empty value (or undefined) it clears the current list of sync tokens.
     * (indicates the service has properly absorbed values into the cluster).
     *
     * @param syncTokenHeaderValue - The full value of the sync token header.
     */
    addSyncTokenFromHeaderValue(syncTokenHeaderValue) {
        if (syncTokenHeaderValue == null || syncTokenHeaderValue === "") {
            // eventually everything gets synced up and we don't have to track
            // these headers anymore
            this._currentSyncTokens.clear();
            return;
        }
        const newTokens = syncTokenHeaderValue.split(",").map(parseSyncToken);
        for (const newToken of newTokens) {
            const existingToken = this._currentSyncTokens.get(newToken.id);
            if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {
                this._currentSyncTokens.set(newToken.id, newToken);
                continue;
            }
        }
    }
    /**
     * Gets a properly formatted SyncToken header value.
     */
    getSyncTokenHeaderValue() {
        if (this._currentSyncTokens.size === 0) {
            return undefined;
        }
        const syncTokenStrings = [];
        for (const syncToken of this._currentSyncTokens.values()) {
            // note that you don't include the 'sn' field here - that's only
            // used for internal tracking of the 'version' for the token itself
            syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);
        }
        return syncTokenStrings.join(",");
    }
}
// An example sync token (from their documentation):
//
// jtqGc1I4=MDoyOA==;sn=28
//
// Which breaks down to:
// id: jtqGc1I4
// value: MDoyOA==
// sequence number: 28
const syncTokenRegex = /^([^=]+)=([^;]+);sn=(\d+)$/;
/**
 * Parses a single sync token into it's constituent parts.
 *
 * @param syncToken - A single sync token.
 *
 * @internal
 */
function parseSyncToken(syncToken) {
    const matches = syncToken.match(syncTokenRegex);
    if (matches == null) {
        throw new Error(`Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`);
    }
    const sequenceNumber = parseInt(matches[3], 10);
    if (isNaN(sequenceNumber)) {
        // this should be impossible since our regex restricts to just digits
        // but there's nothing wrong with being thorough.
        throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);
    }
    return {
        id: matches[1],
        value: matches[2],
        sequenceNumber
    };
}

// Copyright (c) Microsoft Corporation.
const packageName$1 = "azsdk-js-app-configuration";
/**
 * This constant should always be the same as the package.json's version - we use it when forming the
 * User - Agent header. There's a unit test that makes sure it always stays in sync.
 * @internal
 */
const packageVersion$1 = "1.3.1";
const apiVersion$1 = "1.0";
const ConnectionStringRegex = /Endpoint=(.*);Id=(.*);Secret=(.*)/;
const deserializationContentTypes = {
    json: [
        "application/vnd.microsoft.appconfig.kvset+json",
        "application/vnd.microsoft.appconfig.kv+json",
        "application/vnd.microsoft.appconfig.kvs+json",
        "application/vnd.microsoft.appconfig.keyset+json",
        "application/vnd.microsoft.appconfig.revs+json"
    ]
};
/**
 * Client for the Azure App Configuration service.
 */
class AppConfigurationClient {
    constructor(connectionStringOrEndpoint, tokenCredentialOrOptions, options) {
        // (for tests)
        this._trace = trace;
        let appConfigOptions = {};
        let appConfigCredential;
        let appConfigEndpoint;
        if (coreHttp.isTokenCredential(tokenCredentialOrOptions)) {
            appConfigOptions = options || {};
            appConfigCredential = tokenCredentialOrOptions;
            appConfigEndpoint = connectionStringOrEndpoint;
        }
        else {
            appConfigOptions = tokenCredentialOrOptions || {};
            const regexMatch = connectionStringOrEndpoint === null || connectionStringOrEndpoint === void 0 ? void 0 : connectionStringOrEndpoint.match(ConnectionStringRegex);
            if (regexMatch) {
                appConfigCredential = new AppConfigCredential(regexMatch[2], regexMatch[3]);
                appConfigEndpoint = regexMatch[1];
            }
            else {
                throw new Error(`Invalid connection string. Valid connection strings should match the regex '${ConnectionStringRegex.source}'.`);
            }
        }
        this._syncTokens = appConfigOptions.syncTokens || new SyncTokens();
        this.client = new AppConfiguration(appConfigCredential, appConfigEndpoint, apiVersion$1, getGeneratedClientOptions(appConfigEndpoint, this._syncTokens, appConfigOptions));
    }
    /**
     * Add a setting into the Azure App Configuration service, failing if it
     * already exists.
     *
     * Example usage:
     * ```ts
     * const result = await client.addConfigurationSetting({ key: "MyKey", label: "MyLabel", value: "MyValue" });
     * ```
     * @param configurationSetting - A configuration setting.
     * @param options - Optional parameters for the request.
     */
    addConfigurationSetting(configurationSetting, options = {}) {
        return this._trace("addConfigurationSetting", options, async (newOptions) => {
            const keyValue = serializeAsConfigurationSettingParam(configurationSetting);
            const originalResponse = await this.client.putKeyValue(configurationSetting.key, Object.assign({ ifNoneMatch: "*", label: configurationSetting.label, entity: keyValue }, newOptions));
            return transformKeyValueResponse(originalResponse);
        });
    }
    /**
     * Delete a setting from the Azure App Configuration service
     *
     * Example usage:
     * ```ts
     * const deletedSetting = await client.deleteConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id - The id of the configuration setting to delete.
     * @param options - Optional parameters for the request (ex: etag, label)
     */
    deleteConfigurationSetting(id, options = {}) {
        return this._trace("deleteConfigurationSetting", options, async (newOptions) => {
            const originalResponse = await this.client.deleteKeyValue(id.key, Object.assign(Object.assign({ label: id.label }, newOptions), checkAndFormatIfAndIfNoneMatch(id, options)));
            return transformKeyValueResponseWithStatusCode(originalResponse);
        });
    }
    /**
     * Gets a setting from the Azure App Configuration service.
     *
     * Example code:
     * ```ts
     * const setting = await client.getConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id - The id of the configuration setting to get.
     * @param options - Optional parameters for the request.
     */
    async getConfigurationSetting(id, options = {}) {
        return this._trace("getConfigurationSetting", options, async (newOptions) => {
            const originalResponse = await this.client.getKeyValue(id.key, Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label, select: formatFieldsForSelect(options.fields) }), formatAcceptDateTime(options)), checkAndFormatIfAndIfNoneMatch(id, options)));
            const response = transformKeyValueResponseWithStatusCode(originalResponse);
            // 304 only comes back if the user has passed a conditional option in their
            // request _and_ the remote object has the same etag as what the user passed.
            if (response.statusCode === 304) {
                // this is one of our few 'required' fields so we'll make sure it does get initialized
                // with a value
                response.key = id.key;
                // and now we'll undefine all the other properties that are not HTTP related
                makeConfigurationSettingEmpty(response);
            }
            return response;
        });
    }
    /**
     * Lists settings from the Azure App Configuration service, optionally
     * filtered by key names, labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const allSettingsWithLabel = client.listConfigurationSettings({ labelFilter: "MyLabel" });
     * ```
     * @param options - Optional parameters for the request.
     */
    listConfigurationSettings(options = {}) {
        const iter = this.getListConfigurationSettingsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listConfigurationSettingsByPage(Object.assign(Object.assign({}, options), { continuationToken: settings.continuationToken }));
            }
        };
    }
    getListConfigurationSettingsIterator(options) {
        return tslib.__asyncGenerator(this, arguments, function* getListConfigurationSettingsIterator_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationSettingsByPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const configurationSetting of page.items) {
                        yield yield tslib.__await(configurationSetting);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listConfigurationSettingsByPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSettingsByPage_1() {
            let currentResponse = yield tslib.__await(this._trace("listConfigurationSettings", options, async (newOptions) => {
                const response = await this.client.getKeyValues(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: options.continuationToken }));
                return response;
            }));
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield tslib.__await(this._trace("listConfigurationSettings", options, 
                // TODO: same code up above. Unify.
                async (newOptions) => {
                    const response = await this.client.getKeyValues(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                    return response;
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            }
        });
    }
    *createListConfigurationPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [], continuationToken: currentResponse.nextLink
                ? extractAfterTokenFromNextLink(currentResponse.nextLink)
                : undefined });
    }
    /**
     * Lists revisions of a set of keys, optionally filtered by key names,
     * labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const revisionsIterator = client.listRevisions({ keys: ["MyKey"] });
     * ```
     * @param options - Optional parameters for the request.
     */
    listRevisions(options) {
        const iter = this.getListRevisionsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listRevisionsByPage(Object.assign(Object.assign({}, options), { continuationToken: settings.continuationToken }));
            }
        };
    }
    getListRevisionsIterator(options) {
        return tslib.__asyncGenerator(this, arguments, function* getListRevisionsIterator_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRevisionsByPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page.items) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    listRevisionsByPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsByPage_1() {
            let currentResponse = yield tslib.__await(this._trace("listRevisions", options, async (newOptions) => {
                const response = await this.client.getRevisions(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(newOptions)), { after: options.continuationToken }));
                return response;
            }));
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListRevisionsPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield tslib.__await(this._trace("listRevisions", options, (newOptions) => {
                    return this.client.getRevisions(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListRevisionsPageFromResponse(currentResponse))));
            }
        });
    }
    *createListRevisionsPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [], continuationToken: currentResponse.nextLink
                ? extractAfterTokenFromNextLink(currentResponse.nextLink)
                : undefined });
    }
    /**
     * Sets the value of a key in the Azure App Configuration service, allowing for an optional etag.
     * @param key - The name of the key.
     * @param configurationSetting - A configuration value.
     * @param options - Optional parameters for the request.
     *
     * Example code:
     * ```ts
     * await client.setConfigurationSetting({ key: "MyKey", value: "MyValue" });
     * ```
     */
    async setConfigurationSetting(configurationSetting, options = {}) {
        return this._trace("setConfigurationSetting", options, async (newOptions) => {
            const keyValue = serializeAsConfigurationSettingParam(configurationSetting);
            const response = await this.client.putKeyValue(configurationSetting.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: configurationSetting.label, entity: keyValue }), checkAndFormatIfAndIfNoneMatch(configurationSetting, options)));
            return transformKeyValueResponse(response);
        });
    }
    /**
     * Sets or clears a key's read-only status.
     * @param id - The id of the configuration setting to modify.
     */
    async setReadOnly(id, readOnly, options = {}) {
        return this._trace("setReadOnly", options, async (newOptions) => {
            if (readOnly) {
                const response = await this.client.putLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                return transformKeyValueResponse(response);
            }
            else {
                const response = await this.client.deleteLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                return transformKeyValueResponse(response);
            }
        });
    }
    /**
     * Adds an external synchronization token to ensure service requests receive up-to-date values.
     *
     * @param syncToken - The synchronization token value.
     */
    updateSyncToken(syncToken) {
        this._syncTokens.addSyncTokenFromHeaderValue(syncToken);
    }
}
/**
 * Gets the options for the generated AppConfigurationClient
 * @internal
 */
function getGeneratedClientOptions(endpoint, syncTokens, internalAppConfigOptions) {
    const retryPolicies = [
        coreHttp.exponentialRetryPolicy(),
        coreHttp.systemErrorRetryPolicy(),
        throttlingRetryPolicy(internalAppConfigOptions.retryOptions)
    ];
    const userAgent = getUserAgentPrefix(internalAppConfigOptions.userAgentOptions &&
        internalAppConfigOptions.userAgentOptions.userAgentPrefix);
    return {
        endpoint,
        deserializationContentTypes,
        // we'll add in our own custom retry policies
        noRetryPolicy: true,
        requestPolicyFactories: (defaults) => [
            coreHttp.tracingPolicy({ userAgent }),
            syncTokenPolicy(syncTokens),
            coreHttp.userAgentPolicy({ value: userAgent }),
            ...retryPolicies,
            ...defaults
        ],
        generateClientRequestIdHeader: true
    };
}
/**
 * @internal
 */
function getUserAgentPrefix(userSuppliedUserAgent) {
    const appConfigDefaultUserAgent = `${packageName$1}/${packageVersion$1} ${coreHttp.getDefaultUserAgentValue()}`;
    if (!userSuppliedUserAgent) {
        return appConfigDefaultUserAgent;
    }
    return `${userSuppliedUserAgent} ${appConfigDefaultUserAgent}`;
}

exports.AppConfigurationClient = AppConfigurationClient;
exports.featureFlagContentType = featureFlagContentType;
exports.featureFlagPrefix = featureFlagPrefix;
exports.isFeatureFlag = isFeatureFlag;
exports.isSecretReference = isSecretReference;
exports.parseFeatureFlag = parseFeatureFlag;
exports.parseSecretReference = parseSecretReference;
exports.secretReferenceContentType = secretReferenceContentType;
//# sourceMappingURL=index.js.map
