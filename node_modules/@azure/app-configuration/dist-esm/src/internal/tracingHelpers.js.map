{"version":3,"file":"tracingHelpers.js","sourceRoot":"","sources":["../../../src/internal/tracingHelpers.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAQ,cAAc,EAAE,MAAM,qBAAqB,CAAC;AAE3D,OAAO,EAAE,SAAS,EAAoB,MAAM,kBAAkB,CAAC;AAC/D,OAAO,EAAE,kBAAkB,EAAE,MAAM,qBAAqB,CAAC;AAGzD,gBAAgB;AAChB,MAAM,CAAC,MAAM,UAAU,GAAG,kBAAkB,CAAC;IAC3C,SAAS,EAAE,4BAA4B;IACvC,aAAa,EAAE,6BAA6B;CAC7C,CAAC,CAAC;AAEH;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CACzB,aAA2C,EAC3C,OAAyB,EACzB,EAA+D,EAC/D,YAAY,GAAG,UAAU;IAEzB,MAAM,EAAE,cAAc,EAAE,IAAI,EAAE,GAAG,YAAY,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;IAEtE,IAAI;QACF,6GAA6G;QAC7G,kBAAkB;QAClB,MAAM,MAAM,GAAG,MAAM,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC,CAAC;QAE9C,IAAI,CAAC,SAAS,CAAC;YACb,IAAI,EAAE,cAAc,CAAC,EAAE;SACxB,CAAC,CAAC;QACH,OAAO,MAAM,CAAC;KACf;IAAC,OAAO,GAAG,EAAE;QACZ,IAAI,CAAC,SAAS,CAAC;YACb,IAAI,EAAE,cAAc,CAAC,KAAK;YAC1B,OAAO,EAAE,GAAG,CAAC,OAAO;SACrB,CAAC,CAAC;QACH,MAAM,GAAG,CAAC;KACX;YAAS;QACR,IAAI,CAAC,GAAG,EAAE,CAAC;KACZ;AACH,CAAC;AAED,gBAAgB;AAChB,MAAM,UAAU,WAAW,CAAC,GAAU;IACpC,OAAO,GAAG,YAAY,SAAS,CAAC;AAClC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Span, SpanStatusCode } from \"@azure/core-tracing\";\n\nimport { RestError, OperationOptions } from \"@azure/core-http\";\nimport { createSpanFunction } from \"@azure/core-tracing\";\nimport { AppConfigurationClient } from \"../appConfigurationClient\";\n\n/** @internal */\nexport const createSpan = createSpanFunction({\n  namespace: \"Microsoft.AppConfiguration\",\n  packagePrefix: \"Azure.Data.AppConfiguration\"\n});\n\n/**\n * Traces an operation and properly handles reporting start, end and errors for a given span\n *\n * @param operationName - Name of a method in the TClient type\n * @param options - An options class, typically derived from \\@azure/core-http/RequestOptionsBase\n * @param fn - The function to call with an options class that properly propagates the span context\n *\n * @internal\n */\nexport async function trace<ReturnT>(\n  operationName: keyof AppConfigurationClient,\n  options: OperationOptions,\n  fn: (options: OperationOptions, span: Span) => Promise<ReturnT>,\n  createSpanFn = createSpan\n): Promise<ReturnT> {\n  const { updatedOptions, span } = createSpanFn(operationName, options);\n\n  try {\n    // NOTE: we really do need to await on this function here so we can handle any exceptions thrown and properly\n    // close the span.\n    const result = await fn(updatedOptions, span);\n\n    span.setStatus({\n      code: SpanStatusCode.OK\n    });\n    return result;\n  } catch (err) {\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: err.message\n    });\n    throw err;\n  } finally {\n    span.end();\n  }\n}\n\n/** @internal */\nexport function isRestError(err: Error): err is RestError {\n  return err instanceof RestError;\n}\n"]}