{"version":3,"file":"synctokenpolicy.js","sourceRoot":"","sources":["../../../src/internal/synctokenpolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  RequestPolicy,\n  RequestPolicyOptions,\n  BaseRequestPolicy,\n  WebResource,\n  HttpOperationResponse,\n  RequestPolicyFactory\n} from \"@azure/core-http\";\n\n/**\n * The sync token header, as described here:\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n * @internal\n */\nexport const SyncTokenHeaderName = \"sync-token\";\n\n/**\n * A policy factory for injecting sync tokens properly into outgoing requests.\n * @param syncTokens - the sync tokens store to be used across requests.\n * @internal\n */\nexport function syncTokenPolicy(syncTokens: SyncTokens): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SyncTokenPolicy(nextPolicy, options, syncTokens);\n    }\n  };\n}\n\nclass SyncTokenPolicy extends BaseRequestPolicy {\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    private _syncTokens: SyncTokens\n  ) {\n    super(nextPolicy, options);\n  }\n\n  public async sendRequest(webResource: WebResource): Promise<HttpOperationResponse> {\n    const syncTokenHeaderValue = this._syncTokens.getSyncTokenHeaderValue();\n\n    if (syncTokenHeaderValue != null) {\n      webResource.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);\n    }\n\n    const response = await this._nextPolicy.sendRequest(webResource);\n    this._syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));\n    return response;\n  }\n}\n\n/**\n * Sync token tracker (allows for real-time consistency, even in the face of\n * caching and load balancing within App Configuration).\n *\n * (protocol and format described here)\n * https://docs.microsoft.com/azure/azure-app-configuration/rest-api-consistency\n *\n * @internal\n */\nexport class SyncTokens {\n  private _currentSyncTokens = new Map<string, SyncToken>();\n\n  /**\n   * Takes the value from the header named after the constant `SyncTokenHeaderName`\n   * and adds it to our list of accumulated sync tokens.\n   *\n   * If given an empty value (or undefined) it clears the current list of sync tokens.\n   * (indicates the service has properly absorbed values into the cluster).\n   *\n   * @param syncTokenHeaderValue - The full value of the sync token header.\n   */\n  addSyncTokenFromHeaderValue(syncTokenHeaderValue: string | undefined): void {\n    if (syncTokenHeaderValue == null || syncTokenHeaderValue === \"\") {\n      // eventually everything gets synced up and we don't have to track\n      // these headers anymore\n      this._currentSyncTokens.clear();\n      return;\n    }\n\n    const newTokens = syncTokenHeaderValue.split(\",\").map(parseSyncToken);\n\n    for (const newToken of newTokens) {\n      const existingToken = this._currentSyncTokens.get(newToken.id);\n\n      if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {\n        this._currentSyncTokens.set(newToken.id, newToken);\n        continue;\n      }\n    }\n  }\n\n  /**\n   * Gets a properly formatted SyncToken header value.\n   */\n  getSyncTokenHeaderValue(): string | undefined {\n    if (this._currentSyncTokens.size === 0) {\n      return undefined;\n    }\n\n    const syncTokenStrings = [];\n\n    for (const syncToken of this._currentSyncTokens.values()) {\n      // note that you don't include the 'sn' field here - that's only\n      // used for internal tracking of the 'version' for the token itself\n      syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);\n    }\n\n    return syncTokenStrings.join(\",\");\n  }\n}\n\n// An example sync token (from their documentation):\n//\n// jtqGc1I4=MDoyOA==;sn=28\n//\n// Which breaks down to:\n// id: jtqGc1I4\n// value: MDoyOA==\n// sequence number: 28\nconst syncTokenRegex = /^([^=]+)=([^;]+);sn=(\\d+)$/;\n\ninterface SyncToken {\n  id: string;\n  value: string;\n  sequenceNumber: number;\n}\n\n/**\n * Parses a single sync token into it's constituent parts.\n *\n * @param syncToken - A single sync token.\n *\n * @internal\n */\nexport function parseSyncToken(syncToken: string): SyncToken {\n  const matches = syncToken.match(syncTokenRegex);\n\n  if (matches == null) {\n    throw new Error(\n      `Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`\n    );\n  }\n\n  const sequenceNumber = parseInt(matches[3], 10);\n\n  if (isNaN(sequenceNumber)) {\n    // this should be impossible since our regex restricts to just digits\n    // but there's nothing wrong with being thorough.\n    throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);\n  }\n\n  return {\n    id: matches[1],\n    value: matches[2],\n    sequenceNumber\n  };\n}\n"]}