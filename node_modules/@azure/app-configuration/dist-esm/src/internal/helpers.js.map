{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/internal/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { featureFlagContentType, ListConfigurationSettingsOptions } from \"..\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport {\n  ListRevisionsOptions,\n  ConfigurationSettingId,\n  ConfigurationSetting,\n  HttpResponseField,\n  HttpResponseFields,\n  HttpOnlyIfChangedField,\n  HttpOnlyIfUnchangedField,\n  ConfigurationSettingParam\n} from \"../models\";\nimport { AppConfigurationGetKeyValuesOptionalParams, KeyValue } from \"../generated/src/models\";\nimport { FeatureFlagHelper, FeatureFlagValue } from \"../featureFlag\";\nimport {\n  secretReferenceContentType,\n  SecretReferenceHelper,\n  SecretReferenceValue\n} from \"../secretReference\";\nimport { isDefined } from \"./typeguards\";\n\n/**\n * Formats the etag so it can be used with a If-Match/If-None-Match header\n * @internal\n */\nexport function quoteETag(etag: string | undefined): string | undefined {\n  // https://tools.ietf.org/html/rfc7232#section-3.1\n  if (etag === undefined || etag === \"*\") {\n    return etag;\n  }\n\n  if (etag.startsWith('\"') && etag.endsWith('\"')) {\n    return etag;\n  }\n\n  if (etag.startsWith(\"'\") && etag.endsWith(\"'\")) {\n    return etag;\n  }\n\n  return `\"${etag}\"`;\n}\n\n/**\n * Checks the onlyIfChanged/onlyIfUnchanged properties to make sure we haven't specified both\n * and throws an Error. Otherwise, returns the properties properly quoted.\n * @param options - An options object with onlyIfChanged/onlyIfUnchanged fields\n * @internal\n */\nexport function checkAndFormatIfAndIfNoneMatch(\n  configurationSetting: ConfigurationSettingId,\n  options: HttpOnlyIfChangedField & HttpOnlyIfUnchangedField\n): { ifMatch: string | undefined; ifNoneMatch: string | undefined } {\n  if (options.onlyIfChanged && options.onlyIfUnchanged) {\n    throw new Error(\"onlyIfChanged and onlyIfUnchanged are mutually-exclusive\");\n  }\n\n  let ifMatch;\n  let ifNoneMatch;\n\n  if (options.onlyIfUnchanged) {\n    ifMatch = quoteETag(configurationSetting.etag);\n  }\n\n  if (options.onlyIfChanged) {\n    ifNoneMatch = quoteETag(configurationSetting.etag);\n  }\n\n  return {\n    ifMatch: ifMatch,\n    ifNoneMatch: ifNoneMatch\n  };\n}\n\n/**\n * Transforms some of the key fields in ListConfigurationSettingsOptions and ListRevisionsOptions\n * so they can be added to a request using AppConfigurationGetKeyValuesOptionalParams.\n * - `options.acceptDateTime` is converted into an ISO string\n * - `select` is populated with the proper field names from `options.fields`\n * - keyFilter and labelFilter are moved to key and label, respectively.\n *\n * @internal\n */\nexport function formatFiltersAndSelect(\n  listConfigOptions: ListConfigurationSettingsOptions | ListRevisionsOptions\n): Pick<AppConfigurationGetKeyValuesOptionalParams, \"key\" | \"label\" | \"select\" | \"acceptDatetime\"> {\n  let acceptDatetime: string | undefined = undefined;\n\n  if (listConfigOptions.acceptDateTime) {\n    acceptDatetime = listConfigOptions.acceptDateTime.toISOString();\n  }\n\n  return {\n    key: listConfigOptions.keyFilter,\n    label: listConfigOptions.labelFilter,\n    acceptDatetime,\n    select: formatFieldsForSelect(listConfigOptions.fields)\n  };\n}\n\n/**\n * Handles translating a Date acceptDateTime into a string as needed by the API\n * @param newOptions - A newer style options with acceptDateTime as a date (and with proper casing!)\n * @internal\n */\nexport function formatAcceptDateTime(newOptions: {\n  acceptDateTime?: Date;\n}): { acceptDatetime?: string } {\n  return {\n    acceptDatetime: newOptions.acceptDateTime && newOptions.acceptDateTime.toISOString()\n  };\n}\n\n/**\n * Take the URL that gets returned from next link and extract the 'after' token needed\n * to get the next page of results.\n * @internal\n */\nexport function extractAfterTokenFromNextLink(nextLink: string): string {\n  const parsedLink = URLBuilder.parse(nextLink);\n  const afterToken = parsedLink.getQueryParameterValue(\"after\");\n\n  if (afterToken == null || Array.isArray(afterToken)) {\n    throw new Error(\"Invalid nextLink - invalid after token\");\n  }\n\n  return decodeURIComponent(afterToken);\n}\n\n/**\n * Makes a ConfigurationSetting-based response throw for all of the data members. Used primarily\n * to prevent possible errors by the user in accessing a model that is uninitialized. This can happen\n * in cases like HTTP status code 204 or 304, which return an empty response body.\n *\n * @param configurationSetting - The configuration setting to alter\n */\nexport function makeConfigurationSettingEmpty(\n  configurationSetting: Partial<Record<Exclude<keyof ConfigurationSetting, \"key\">, any>>\n): void {\n  const names: Exclude<keyof ConfigurationSetting, \"key\">[] = [\n    \"contentType\",\n    \"etag\",\n    \"label\",\n    \"lastModified\",\n    \"isReadOnly\",\n    \"tags\",\n    \"value\"\n  ];\n\n  for (const name of names) {\n    configurationSetting[name] = undefined;\n  }\n}\n\n/**\n * @internal\n */\nexport function transformKeyValue(kvp: KeyValue): ConfigurationSetting {\n  const setting: ConfigurationSetting & KeyValue = {\n    value: undefined,\n    ...kvp,\n    isReadOnly: !!kvp.locked\n  };\n\n  delete setting.locked;\n\n  return setting;\n}\n\n/**\n * @internal\n */\nfunction isConfigSettingWithSecretReferenceValue(\n  setting: any\n): setting is ConfigurationSetting<SecretReferenceValue> {\n  return (\n    setting.contentType === secretReferenceContentType &&\n    isDefined(setting.value) &&\n    typeof setting.value !== \"string\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isConfigSettingWithFeatureFlagValue(\n  setting: any\n): setting is ConfigurationSetting<FeatureFlagValue> {\n  return (\n    setting.contentType === featureFlagContentType &&\n    isDefined(setting.value) &&\n    typeof setting.value !== \"string\"\n  );\n}\n\n/**\n * @internal\n */\nfunction isSimpleConfigSetting(setting: any): setting is ConfigurationSetting {\n  return typeof setting.value === \"string\" || !isDefined(setting.value);\n}\n\n/**\n * @internal\n */\nexport function serializeAsConfigurationSettingParam(\n  setting:\n    | ConfigurationSettingParam\n    | ConfigurationSettingParam<FeatureFlagValue>\n    | ConfigurationSettingParam<SecretReferenceValue>\n): ConfigurationSettingParam {\n  if (isSimpleConfigSetting(setting)) {\n    return setting as ConfigurationSettingParam;\n  }\n  try {\n    if (isConfigSettingWithFeatureFlagValue(setting)) {\n      return FeatureFlagHelper.toConfigurationSettingParam(setting);\n    }\n    if (isConfigSettingWithSecretReferenceValue(setting)) {\n      return SecretReferenceHelper.toConfigurationSettingParam(setting);\n    }\n  } catch (error) {\n    return setting as ConfigurationSettingParam;\n  }\n  throw new TypeError(\n    `Unable to serialize the setting with key \"${setting.key}\" as a configuration setting`\n  );\n}\n\n/**\n * @internal\n */\nexport function transformKeyValueResponseWithStatusCode<\n  T extends KeyValue & HttpResponseField<any>\n>(kvp: T): ConfigurationSetting & { eTag?: string } & HttpResponseField<any> & HttpResponseFields {\n  return normalizeResponse(kvp, <\n    ConfigurationSetting & HttpResponseField<any> & HttpResponseFields\n  >{\n    ...transformKeyValue(kvp),\n    statusCode: kvp._response.status\n  });\n}\n\n/**\n * @internal\n */\nexport function transformKeyValueResponse<\n  T extends KeyValue & { eTag?: string } & HttpResponseField<any>\n>(kvp: T): ConfigurationSetting & HttpResponseField<any> {\n  return normalizeResponse(kvp, <ConfigurationSetting & HttpResponseField<any>>{\n    ...transformKeyValue(kvp)\n  });\n}\n\nfunction normalizeResponse<T extends HttpResponseField<any> & { eTag?: string }>(\n  originalResponse: HttpResponseField<any>,\n  newResponse: T\n): T {\n  Object.defineProperty(newResponse, \"_response\", {\n    enumerable: false,\n    value: originalResponse._response\n  });\n\n  // this field comes from the header but it's redundant with\n  // the one serialized in the model itself\n  delete newResponse.eTag;\n\n  return newResponse;\n}\n\n/**\n * Translates user-facing field names into their `select` equivalents (these can be\n * seen in the `KnownEnum5`)\n *\n * @param fieldNames - fieldNames from users.\n * @returns The field names translated into the `select` field equivalents.\n *\n * @internal\n */\nexport function formatFieldsForSelect(\n  fieldNames: (keyof ConfigurationSetting)[] | undefined\n): string[] | undefined {\n  if (fieldNames == null) {\n    return undefined;\n  }\n\n  const mappedFieldNames = fieldNames.map((fn) => {\n    switch (fn) {\n      case \"lastModified\":\n        return \"last_modified\";\n      case \"contentType\":\n        return \"content_type\";\n      case \"isReadOnly\":\n        return \"locked\";\n      default:\n        return fn;\n    }\n  });\n\n  return mappedFieldNames;\n}\n\n/**\n * @internal\n */\nexport function errorMessageForUnexpectedSetting(\n  key: string,\n  expectedType: \"FeatureFlag\" | \"SecretReference\"\n): string {\n  return `Setting with key ${key} is not a valid ${expectedType}, make sure to have the correct content-type and a valid non-null value.`;\n}\n"]}