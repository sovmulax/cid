// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from "tslib";
// https://azure.github.io/azure-sdk/typescript_design.html#ts-config-lib
/// <reference lib="esnext.asynciterable" />
import { AppConfigCredential } from "./appConfigCredential";
import { AppConfiguration } from "./generated/src/appConfiguration";
import { isTokenCredential, exponentialRetryPolicy, systemErrorRetryPolicy, getDefaultUserAgentValue as getCoreHttpDefaultUserAgentValue, userAgentPolicy } from "@azure/core-http";
import { throttlingRetryPolicy } from "./policies/throttlingRetryPolicy";
import "@azure/core-asynciterator-polyfill";
import { checkAndFormatIfAndIfNoneMatch, extractAfterTokenFromNextLink, formatFiltersAndSelect, makeConfigurationSettingEmpty, transformKeyValueResponse, transformKeyValueResponseWithStatusCode, transformKeyValue, formatAcceptDateTime, formatFieldsForSelect, serializeAsConfigurationSettingParam } from "./internal/helpers";
import { tracingPolicy } from "@azure/core-http";
import { trace as traceFromTracingHelpers } from "./internal/tracingHelpers";
import { syncTokenPolicy, SyncTokens } from "./internal/synctokenpolicy";
const packageName = "azsdk-js-app-configuration";
/**
 * This constant should always be the same as the package.json's version - we use it when forming the
 * User - Agent header. There's a unit test that makes sure it always stays in sync.
 * @internal
 */
export const packageVersion = "1.3.1";
const apiVersion = "1.0";
const ConnectionStringRegex = /Endpoint=(.*);Id=(.*);Secret=(.*)/;
const deserializationContentTypes = {
    json: [
        "application/vnd.microsoft.appconfig.kvset+json",
        "application/vnd.microsoft.appconfig.kv+json",
        "application/vnd.microsoft.appconfig.kvs+json",
        "application/vnd.microsoft.appconfig.keyset+json",
        "application/vnd.microsoft.appconfig.revs+json"
    ]
};
/**
 * Client for the Azure App Configuration service.
 */
export class AppConfigurationClient {
    constructor(connectionStringOrEndpoint, tokenCredentialOrOptions, options) {
        // (for tests)
        this._trace = traceFromTracingHelpers;
        let appConfigOptions = {};
        let appConfigCredential;
        let appConfigEndpoint;
        if (isTokenCredential(tokenCredentialOrOptions)) {
            appConfigOptions = options || {};
            appConfigCredential = tokenCredentialOrOptions;
            appConfigEndpoint = connectionStringOrEndpoint;
        }
        else {
            appConfigOptions = tokenCredentialOrOptions || {};
            const regexMatch = connectionStringOrEndpoint === null || connectionStringOrEndpoint === void 0 ? void 0 : connectionStringOrEndpoint.match(ConnectionStringRegex);
            if (regexMatch) {
                appConfigCredential = new AppConfigCredential(regexMatch[2], regexMatch[3]);
                appConfigEndpoint = regexMatch[1];
            }
            else {
                throw new Error(`Invalid connection string. Valid connection strings should match the regex '${ConnectionStringRegex.source}'.`);
            }
        }
        this._syncTokens = appConfigOptions.syncTokens || new SyncTokens();
        this.client = new AppConfiguration(appConfigCredential, appConfigEndpoint, apiVersion, getGeneratedClientOptions(appConfigEndpoint, this._syncTokens, appConfigOptions));
    }
    /**
     * Add a setting into the Azure App Configuration service, failing if it
     * already exists.
     *
     * Example usage:
     * ```ts
     * const result = await client.addConfigurationSetting({ key: "MyKey", label: "MyLabel", value: "MyValue" });
     * ```
     * @param configurationSetting - A configuration setting.
     * @param options - Optional parameters for the request.
     */
    addConfigurationSetting(configurationSetting, options = {}) {
        return this._trace("addConfigurationSetting", options, async (newOptions) => {
            const keyValue = serializeAsConfigurationSettingParam(configurationSetting);
            const originalResponse = await this.client.putKeyValue(configurationSetting.key, Object.assign({ ifNoneMatch: "*", label: configurationSetting.label, entity: keyValue }, newOptions));
            return transformKeyValueResponse(originalResponse);
        });
    }
    /**
     * Delete a setting from the Azure App Configuration service
     *
     * Example usage:
     * ```ts
     * const deletedSetting = await client.deleteConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id - The id of the configuration setting to delete.
     * @param options - Optional parameters for the request (ex: etag, label)
     */
    deleteConfigurationSetting(id, options = {}) {
        return this._trace("deleteConfigurationSetting", options, async (newOptions) => {
            const originalResponse = await this.client.deleteKeyValue(id.key, Object.assign(Object.assign({ label: id.label }, newOptions), checkAndFormatIfAndIfNoneMatch(id, options)));
            return transformKeyValueResponseWithStatusCode(originalResponse);
        });
    }
    /**
     * Gets a setting from the Azure App Configuration service.
     *
     * Example code:
     * ```ts
     * const setting = await client.getConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id - The id of the configuration setting to get.
     * @param options - Optional parameters for the request.
     */
    async getConfigurationSetting(id, options = {}) {
        return this._trace("getConfigurationSetting", options, async (newOptions) => {
            const originalResponse = await this.client.getKeyValue(id.key, Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label, select: formatFieldsForSelect(options.fields) }), formatAcceptDateTime(options)), checkAndFormatIfAndIfNoneMatch(id, options)));
            const response = transformKeyValueResponseWithStatusCode(originalResponse);
            // 304 only comes back if the user has passed a conditional option in their
            // request _and_ the remote object has the same etag as what the user passed.
            if (response.statusCode === 304) {
                // this is one of our few 'required' fields so we'll make sure it does get initialized
                // with a value
                response.key = id.key;
                // and now we'll undefine all the other properties that are not HTTP related
                makeConfigurationSettingEmpty(response);
            }
            return response;
        });
    }
    /**
     * Lists settings from the Azure App Configuration service, optionally
     * filtered by key names, labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const allSettingsWithLabel = client.listConfigurationSettings({ labelFilter: "MyLabel" });
     * ```
     * @param options - Optional parameters for the request.
     */
    listConfigurationSettings(options = {}) {
        const iter = this.getListConfigurationSettingsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listConfigurationSettingsByPage(Object.assign(Object.assign({}, options), { continuationToken: settings.continuationToken }));
            }
        };
    }
    getListConfigurationSettingsIterator(options) {
        return __asyncGenerator(this, arguments, function* getListConfigurationSettingsIterator_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listConfigurationSettingsByPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const configurationSetting of page.items) {
                        yield yield __await(configurationSetting);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listConfigurationSettingsByPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listConfigurationSettingsByPage_1() {
            let currentResponse = yield __await(this._trace("listConfigurationSettings", options, async (newOptions) => {
                const response = await this.client.getKeyValues(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: options.continuationToken }));
                return response;
            }));
            yield __await(yield* __asyncDelegator(__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield __await(this._trace("listConfigurationSettings", options, 
                // TODO: same code up above. Unify.
                async (newOptions) => {
                    const response = await this.client.getKeyValues(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                    return response;
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield __await(yield* __asyncDelegator(__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            }
        });
    }
    *createListConfigurationPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [], continuationToken: currentResponse.nextLink
                ? extractAfterTokenFromNextLink(currentResponse.nextLink)
                : undefined });
    }
    /**
     * Lists revisions of a set of keys, optionally filtered by key names,
     * labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const revisionsIterator = client.listRevisions({ keys: ["MyKey"] });
     * ```
     * @param options - Optional parameters for the request.
     */
    listRevisions(options) {
        const iter = this.getListRevisionsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listRevisionsByPage(Object.assign(Object.assign({}, options), { continuationToken: settings.continuationToken }));
            }
        };
    }
    getListRevisionsIterator(options) {
        return __asyncGenerator(this, arguments, function* getListRevisionsIterator_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.listRevisionsByPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page.items) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    listRevisionsByPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listRevisionsByPage_1() {
            let currentResponse = yield __await(this._trace("listRevisions", options, async (newOptions) => {
                const response = await this.client.getRevisions(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(newOptions)), { after: options.continuationToken }));
                return response;
            }));
            yield __await(yield* __asyncDelegator(__asyncValues(this.createListRevisionsPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield __await(this._trace("listRevisions", options, (newOptions) => {
                    return this.client.getRevisions(Object.assign(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatFiltersAndSelect(options)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield __await(yield* __asyncDelegator(__asyncValues(this.createListRevisionsPageFromResponse(currentResponse))));
            }
        });
    }
    *createListRevisionsPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [], continuationToken: currentResponse.nextLink
                ? extractAfterTokenFromNextLink(currentResponse.nextLink)
                : undefined });
    }
    /**
     * Sets the value of a key in the Azure App Configuration service, allowing for an optional etag.
     * @param key - The name of the key.
     * @param configurationSetting - A configuration value.
     * @param options - Optional parameters for the request.
     *
     * Example code:
     * ```ts
     * await client.setConfigurationSetting({ key: "MyKey", value: "MyValue" });
     * ```
     */
    async setConfigurationSetting(configurationSetting, options = {}) {
        return this._trace("setConfigurationSetting", options, async (newOptions) => {
            const keyValue = serializeAsConfigurationSettingParam(configurationSetting);
            const response = await this.client.putKeyValue(configurationSetting.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: configurationSetting.label, entity: keyValue }), checkAndFormatIfAndIfNoneMatch(configurationSetting, options)));
            return transformKeyValueResponse(response);
        });
    }
    /**
     * Sets or clears a key's read-only status.
     * @param id - The id of the configuration setting to modify.
     */
    async setReadOnly(id, readOnly, options = {}) {
        return this._trace("setReadOnly", options, async (newOptions) => {
            if (readOnly) {
                const response = await this.client.putLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                return transformKeyValueResponse(response);
            }
            else {
                const response = await this.client.deleteLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                return transformKeyValueResponse(response);
            }
        });
    }
    /**
     * Adds an external synchronization token to ensure service requests receive up-to-date values.
     *
     * @param syncToken - The synchronization token value.
     */
    updateSyncToken(syncToken) {
        this._syncTokens.addSyncTokenFromHeaderValue(syncToken);
    }
}
/**
 * Gets the options for the generated AppConfigurationClient
 * @internal
 */
export function getGeneratedClientOptions(endpoint, syncTokens, internalAppConfigOptions) {
    const retryPolicies = [
        exponentialRetryPolicy(),
        systemErrorRetryPolicy(),
        throttlingRetryPolicy(internalAppConfigOptions.retryOptions)
    ];
    const userAgent = getUserAgentPrefix(internalAppConfigOptions.userAgentOptions &&
        internalAppConfigOptions.userAgentOptions.userAgentPrefix);
    return {
        endpoint,
        deserializationContentTypes,
        // we'll add in our own custom retry policies
        noRetryPolicy: true,
        requestPolicyFactories: (defaults) => [
            tracingPolicy({ userAgent }),
            syncTokenPolicy(syncTokens),
            userAgentPolicy({ value: userAgent }),
            ...retryPolicies,
            ...defaults
        ],
        generateClientRequestIdHeader: true
    };
}
/**
 * @internal
 */
export function getUserAgentPrefix(userSuppliedUserAgent) {
    const appConfigDefaultUserAgent = `${packageName}/${packageVersion} ${getCoreHttpDefaultUserAgentValue()}`;
    if (!userSuppliedUserAgent) {
        return appConfigDefaultUserAgent;
    }
    return `${userSuppliedUserAgent} ${appConfigDefaultUserAgent}`;
}
//# sourceMappingURL=appConfigurationClient.js.map