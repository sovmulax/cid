// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { assert } from "chai";
import { createAppConfigurationClientForTests, startRecorder } from "./utils/testHelpers";
import { featureFlagContentType, featureFlagPrefix } from "../../src";
import { isFeatureFlag, parseFeatureFlag } from "../../src/featureFlag";
describe("AppConfigurationClient - FeatureFlag", () => {
    describe("FeatureFlag configuration setting", () => {
        let client;
        let recorder;
        let baseSetting;
        let addResponse;
        beforeEach(async function () {
            recorder = startRecorder(this);
            client = createAppConfigurationClientForTests() || this.skip();
            baseSetting = {
                value: {
                    conditions: {
                        clientFilters: [
                            {
                                name: "Microsoft.TimeWindow",
                                parameters: {
                                    Start: "Wed, 01 May 2019 13:59:59 GMT",
                                    End: "Mon, 01 July 2019 00:00:00 GMT"
                                }
                            },
                            { name: "FilterX" },
                            {
                                name: "Microsoft.Targeting",
                                parameters: {
                                    Audience: {
                                        Groups: [
                                            { Name: "group-1", RolloutPercentage: 25 },
                                            { Name: "group-2", RolloutPercentage: 45 }
                                        ],
                                        Users: ["userA", "userB"],
                                        DefaultRolloutPercentage: 40
                                    }
                                }
                            },
                            { name: "Microsoft.Percentage", parameters: { Value: 25 } }
                        ]
                    },
                    enabled: false,
                    description: "I'm a description",
                    displayName: "for display"
                },
                isReadOnly: false,
                key: `${featureFlagPrefix + recorder.getUniqueName("name-1")}`,
                contentType: featureFlagContentType,
                label: "label-1"
            };
            addResponse = await client.addConfigurationSetting(baseSetting);
        });
        afterEach(async function () {
            await client.deleteConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            await recorder.stop();
        });
        function assertFeatureFlagProps(actual, expected) {
            assert.equal(isFeatureFlag(actual), true, "Expected to get the feature flag");
            assert.isDefined(actual.value, "Expected the value to be defined");
            const featureFlagValue = parseFeatureFlag(actual).value;
            assert.equal(actual.key, expected.key, "Key from the response from get request is not as expected");
            assert.deepEqual(featureFlagValue.conditions, expected.value.conditions, "conditions from the response from get request is not as expected");
            assert.equal(featureFlagValue.description, expected.value.description);
            assert.equal(featureFlagValue.enabled, expected.value.enabled);
            assert.equal(actual.isReadOnly, expected.isReadOnly);
            assert.equal(actual.label, expected.label);
            assert.equal(actual.contentType, expected.contentType);
        }
        it("can add and get FeatureFlag", async () => {
            assertFeatureFlagProps(addResponse, baseSetting);
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            assertFeatureFlagProps(getResponse, baseSetting);
        });
        it("can add and update FeatureFlag", async () => {
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            assertFeatureFlagProps(getResponse, baseSetting);
            const featureFlag = parseFeatureFlag(getResponse);
            featureFlag.value.enabled = !baseSetting.value.enabled;
            const setResponse = await client.setConfigurationSetting(featureFlag);
            assertFeatureFlagProps(setResponse, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
            const getResponseAfterUpdate = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            assertFeatureFlagProps(getResponseAfterUpdate, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
        });
        it("can add, list and update multiple FeatureFlags", async () => {
            var e_1, _a, e_2, _b;
            const secondSetting = Object.assign(Object.assign({}, baseSetting), { key: `${baseSetting.key}-2` });
            await client.addConfigurationSetting(secondSetting);
            let numberOFFeatureFlagsReceived = 0;
            try {
                for (var _c = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`
                })), _d; _d = await _c.next(), !_d.done;) {
                    const setting = _d.value;
                    numberOFFeatureFlagsReceived++;
                    if (setting.key === baseSetting.key) {
                        assertFeatureFlagProps(setting, baseSetting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
                    }
                    else {
                        assertFeatureFlagProps(setting, secondSetting);
                        const parsedSetting = parseFeatureFlag(setting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, parsedSetting), { value: Object.assign(Object.assign({}, parsedSetting.value), { description: "I'm new description" }) }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.equal(numberOFFeatureFlagsReceived, 2, "Unexpected number of FeatureFlags seen");
            try {
                for (var _e = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`
                })), _f; _f = await _e.next(), !_f.done;) {
                    const setting = _f.value;
                    numberOFFeatureFlagsReceived--;
                    if (setting.key === baseSetting.key) {
                        assertFeatureFlagProps(setting, Object.assign(Object.assign({}, baseSetting), { value: Object.assign(Object.assign({}, baseSetting.value), { enabled: !baseSetting.value.enabled }) }));
                    }
                    else {
                        assertFeatureFlagProps(setting, Object.assign(Object.assign({}, secondSetting), { value: Object.assign(Object.assign({}, secondSetting.value), { description: "I'm new description" }) }));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) await _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            assert.equal(numberOFFeatureFlagsReceived, 0, "Unexpected number of FeatureFlags seen after updating");
            await client.deleteConfigurationSetting({ key: secondSetting.key });
        });
    });
    describe("serializeAsConfigurationSettingParam", () => {
        let client;
        let recorder;
        let featureFlag;
        beforeEach(async function () {
            recorder = startRecorder(this);
            client = createAppConfigurationClientForTests() || this.skip();
            featureFlag = {
                contentType: featureFlagContentType,
                key: `${featureFlagPrefix}${recorder.getUniqueName("name-1")}`,
                isReadOnly: false,
                value: { conditions: { clientFilters: [] }, enabled: true }
            };
        });
        afterEach(async function () {
            await client.deleteConfigurationSetting({ key: featureFlag.key });
            await recorder.stop();
        });
        [`[]`, "Hello World"].forEach((value) => {
            it(`Unexpected value ${value} as feature flag value`, async () => {
                featureFlag.value = value;
                await client.addConfigurationSetting(featureFlag);
                assert.equal((await client.getConfigurationSetting({ key: featureFlag.key })).value, value, "message");
            });
        });
    });
});
//# sourceMappingURL=featureFlag.spec.js.map