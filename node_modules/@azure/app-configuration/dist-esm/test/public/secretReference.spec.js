// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { assert } from "chai";
import { createAppConfigurationClientForTests, startRecorder } from "./utils/testHelpers";
import { isSecretReference, parseSecretReference, secretReferenceContentType } from "../../src";
describe("AppConfigurationClient - SecretReference", () => {
    let client;
    let recorder;
    beforeEach(function () {
        recorder = startRecorder(this);
        client = createAppConfigurationClientForTests() || this.skip();
    });
    afterEach(async function () {
        await recorder.stop();
    });
    describe("SecretReference configuration setting", () => {
        const getBaseSetting = () => {
            return {
                value: {
                    secretId: `https://vault_name.vault.azure.net/secrets/${recorder.getUniqueName("name-2")}`
                },
                isReadOnly: false,
                key: recorder.getUniqueName("name-3"),
                label: "label-s",
                contentType: secretReferenceContentType
            };
        };
        function assertSecretReferenceProps(actual, expected) {
            assert.equal(isSecretReference(actual), true, "Expected to get the SecretReference");
            const actualSecretReference = parseSecretReference(actual);
            if (isSecretReference(actual)) {
                assert.equal(actual.key, expected.key, "Key from the response from get request is not as expected");
                assert.equal(actualSecretReference.value.secretId, expected.value.secretId);
                assert.equal(actual.isReadOnly, expected.isReadOnly);
                assert.equal(actual.label, expected.label);
                assert.equal(actual.contentType, expected.contentType);
            }
        }
        let addResponse;
        let baseSetting;
        beforeEach(async () => {
            baseSetting = getBaseSetting();
            addResponse = await client.addConfigurationSetting(baseSetting);
        });
        afterEach(async () => {
            await client.deleteConfigurationSetting({
                key: baseSetting.key
            });
        });
        it("can add and get SecretReference", async () => {
            assertSecretReferenceProps(addResponse, baseSetting);
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            assertSecretReferenceProps(getResponse, baseSetting);
        });
        it("can add and update SecretReference", async () => {
            const getResponse = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            const newSecretId = `https://vault_name.vault.azure.net/secrets/${recorder.getUniqueName("name-4")}`;
            assertSecretReferenceProps(getResponse, baseSetting);
            const secretReference = parseSecretReference(getResponse);
            secretReference.value.secretId = newSecretId;
            const setResponse = await client.setConfigurationSetting(secretReference);
            assertSecretReferenceProps(setResponse, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
            const getResponseAfterUpdate = await client.getConfigurationSetting({
                key: baseSetting.key,
                label: baseSetting.label
            });
            assertSecretReferenceProps(getResponseAfterUpdate, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
        });
        it("can add, list and update multiple SecretReferences", async () => {
            var e_1, _a, e_2, _b;
            const secondSetting = Object.assign(Object.assign({}, baseSetting), { key: `${baseSetting.key}-2` });
            const newSecretId = `https://vault_name.vault.azure.net/secrets/${recorder.getUniqueName("name-5")}`;
            await client.addConfigurationSetting(secondSetting);
            let numberOFSecretReferencesReceived = 0;
            try {
                for (var _c = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`
                })), _d; _d = await _c.next(), !_d.done;) {
                    const setting = _d.value;
                    numberOFSecretReferencesReceived++;
                    if (setting.key === baseSetting.key) {
                        assertSecretReferenceProps(setting, baseSetting);
                        await client.setConfigurationSetting(Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
                    }
                    else {
                        assertSecretReferenceProps(setting, secondSetting);
                        await client.setReadOnly({ key: setting.key, label: setting.label }, !secondSetting.isReadOnly);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) await _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            assert.equal(numberOFSecretReferencesReceived, 2, "Unexpected number of FeatureFlags seen");
            try {
                for (var _e = __asyncValues(client.listConfigurationSettings({
                    keyFilter: `${baseSetting.key}*`
                })), _f; _f = await _e.next(), !_f.done;) {
                    const setting = _f.value;
                    numberOFSecretReferencesReceived--;
                    if (setting.key === baseSetting.key) {
                        assertSecretReferenceProps(setting, Object.assign(Object.assign({}, baseSetting), { value: { secretId: newSecretId } }));
                    }
                    else {
                        assertSecretReferenceProps(setting, Object.assign(Object.assign({}, secondSetting), { isReadOnly: !secondSetting.isReadOnly }));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) await _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            assert.equal(numberOFSecretReferencesReceived, 0, "Unexpected number of SecretReferences seen after updating");
            await client.deleteConfigurationSetting({ key: secondSetting.key });
        });
    });
    describe("serializeAsConfigurationSettingParam", () => {
        [`[]`, "Hello World"].forEach((value) => {
            it(`Unexpected value ${value} as secret reference value`, async () => {
                const setting = {
                    contentType: secretReferenceContentType,
                    key: recorder.getUniqueName("name-1"),
                    isReadOnly: false,
                    value: { secretId: "id" }
                };
                setting.value = value;
                await client.addConfigurationSetting(setting);
                assert.equal((await client.getConfigurationSetting({ key: setting.key })).value, value, "message");
                await client.deleteConfigurationSetting({ key: setting.key });
            });
        });
    });
});
//# sourceMappingURL=secretReference.spec.js.map