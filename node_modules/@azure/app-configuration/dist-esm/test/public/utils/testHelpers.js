// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { AppConfigurationClient } from "../../../src";
import { env, isPlaybackMode, record } from "@azure-tools/test-recorder";
import { assert } from "chai";
import { DefaultAzureCredential } from "@azure/identity";
import { RestError } from "@azure/core-http";
let connectionStringNotPresentWarning = false;
let tokenCredentialsNotPresentWarning = false;
export function startRecorder(that) {
    const recorderEnvSetup = {
        replaceableVariables: {
            APPCONFIG_CONNECTION_STRING: "Endpoint=https://myappconfig.azconfig.io;Id=123456;Secret=123456",
            AZ_CONFIG_ENDPOINT: "https://myappconfig.azconfig.io",
            AZURE_CLIENT_ID: "azure_client_id",
            AZURE_CLIENT_SECRET: "azure_client_secret",
            AZURE_TENANT_ID: "azuretenantid"
        },
        customizationsOnRecordings: [],
        queryParametersToSkip: []
    };
    return record(that, recorderEnvSetup);
}
export function getTokenAuthenticationCredential() {
    const requiredEnvironmentVariables = [
        "AZ_CONFIG_ENDPOINT",
        "AZURE_CLIENT_ID",
        "AZURE_TENANT_ID",
        "AZURE_CLIENT_SECRET"
    ];
    for (const name of requiredEnvironmentVariables) {
        const value = env[name];
        if (value == null) {
            if (tokenCredentialsNotPresentWarning) {
                tokenCredentialsNotPresentWarning = true;
                console.log("Functional tests not running - set client identity variables to activate");
            }
            return undefined;
        }
    }
    return {
        credential: new DefaultAzureCredential(),
        endpoint: env["AZ_CONFIG_ENDPOINT"]
    };
}
export function createAppConfigurationClientForTests(options) {
    const connectionString = env["APPCONFIG_CONNECTION_STRING"];
    if (connectionString == null) {
        if (!connectionStringNotPresentWarning) {
            connectionStringNotPresentWarning = true;
            console.log("Functional tests not running - set APPCONFIG_CONNECTION_STRING to a valid AppConfig connection string to activate");
        }
        return undefined;
    }
    return new AppConfigurationClient(connectionString, options);
}
export async function deleteKeyCompletely(keys, client) {
    var e_1, _a;
    const settingsIterator = client.listConfigurationSettings({
        keyFilter: keys.join(",")
    });
    try {
        for (var settingsIterator_1 = __asyncValues(settingsIterator), settingsIterator_1_1; settingsIterator_1_1 = await settingsIterator_1.next(), !settingsIterator_1_1.done;) {
            const setting = settingsIterator_1_1.value;
            if (setting.isReadOnly) {
                await client.setReadOnly(setting, false);
            }
            await client.deleteConfigurationSetting({ key: setting.key, label: setting.label });
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (settingsIterator_1_1 && !settingsIterator_1_1.done && (_a = settingsIterator_1.return)) await _a.call(settingsIterator_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
export async function toSortedArray(pagedIterator, compareFn) {
    var e_2, _a, e_3, _b;
    const settings = [];
    try {
        for (var pagedIterator_1 = __asyncValues(pagedIterator), pagedIterator_1_1; pagedIterator_1_1 = await pagedIterator_1.next(), !pagedIterator_1_1.done;) {
            const setting = pagedIterator_1_1.value;
            settings.push(setting);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (pagedIterator_1_1 && !pagedIterator_1_1.done && (_a = pagedIterator_1.return)) await _a.call(pagedIterator_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    let settingsViaPageIterator = [];
    try {
        for (var _c = __asyncValues(pagedIterator.byPage()), _d; _d = await _c.next(), !_d.done;) {
            const page = _d.value;
            settingsViaPageIterator = settingsViaPageIterator.concat(page.items);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_b = _c.return)) await _b.call(_c);
        }
        finally { if (e_3) throw e_3.error; }
    }
    // just a sanity-check
    assert.deepEqual(settings, settingsViaPageIterator);
    settings.sort((a, b) => compareFn
        ? compareFn(a, b)
        : `${a.key}-${a.label}-${a.value}`.localeCompare(`${b.key}-${b.label}-${b.value}`));
    return settings;
}
export function assertEqualSettings(expected, actual) {
    actual = actual.map((setting) => {
        return {
            key: setting.key,
            label: setting.label || undefined,
            value: setting.value,
            isReadOnly: setting.isReadOnly
        };
    });
    assert.deepEqual(expected, actual);
}
export async function assertThrowsRestError(testFunction, expectedStatusCode, message = "") {
    try {
        await testFunction();
        assert.fail(`${message}: No error thrown`);
    }
    catch (err) {
        if (!(err instanceof RestError)) {
            throw new Error("Error is not recognized");
        }
        if (err.name === "RestError") {
            assert.equal(expectedStatusCode, err.statusCode, message);
            return err;
        }
        assert.fail(`${message}: Caught error but wasn't a RestError: ${err}`);
    }
    return new Error("We won't reach this - both cases above throw because of assert.fail()");
}
export async function assertThrowsAbortError(testFunction, message = "") {
    try {
        await testFunction();
        assert.fail(`${message}: No error thrown`);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            throw new Error("Error is not recognized");
        }
        if (isPlaybackMode() && (e.name === "FetchError" || e.name === "AbortError")) {
            return e;
        }
        else {
            assert.equal(e.name, "AbortError");
            return e;
        }
    }
}
//# sourceMappingURL=testHelpers.js.map