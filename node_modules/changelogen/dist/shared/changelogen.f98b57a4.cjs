'use strict';

const scule = require('scule');
const convertGitmoji = require('convert-gitmoji');
const nodeFetchNative = require('node-fetch-native');
const node_path = require('node:path');
const c12 = require('c12');
const pkgTypes = require('pkg-types');
const node_fs = require('node:fs');
const semver = require('semver');
const consola = require('consola');

async function getLastGitTag() {
  const r = await execCommand("git", [
    "--no-pager",
    "tag",
    "-l",
    "--sort=creatordate"
  ]).then((r2) => r2.split("\n"));
  return r[r.length - 1];
}
async function getCurrentGitBranch() {
  return await execCommand("git", ["rev-parse", "--abbrev-ref", "HEAD"]);
}
async function getCurrentGitTag() {
  return await execCommand("git", ["tag", "--points-at", "HEAD"]);
}
async function getCurrentGitRef() {
  return await getCurrentGitTag() || await getCurrentGitBranch();
}
async function getGitDiff(from, to = "HEAD") {
  const r = await execCommand("git", [
    "--no-pager",
    "log",
    `${from ? `${from}...` : ""}${to}`,
    '--pretty="----%n%s|%h|%an|%ae%n%b"',
    "--name-status"
  ]);
  return r.split("----\n").splice(1).map((line) => {
    const [firstLine, ..._body] = line.split("\n");
    const [message, shortHash, authorName, authorEmail] = firstLine.split("|");
    const r2 = {
      message,
      shortHash,
      author: { name: authorName, email: authorEmail },
      body: _body.join("\n")
    };
    return r2;
  });
}
function parseCommits(commits, config) {
  return commits.map((commit) => parseGitCommit(commit, config)).filter(Boolean);
}
const ConventionalCommitRegex = /(?<type>[a-z]+)(\((?<scope>.+)\))?(?<breaking>!)?: (?<description>.+)/i;
const CoAuthoredByRegex = /co-authored-by:\s*(?<name>.+)(<(?<email>.+)>)/gim;
const PullRequestRE = /\([ a-z]*(#\d+)\s*\)/gm;
const IssueRE = /(#\d+)/gm;
function parseGitCommit(commit, config) {
  const match = commit.message.match(ConventionalCommitRegex);
  if (!match) {
    return null;
  }
  const type = match.groups.type;
  let scope = match.groups.scope || "";
  scope = config.scopeMap[scope] || scope;
  const isBreaking = Boolean(match.groups.breaking);
  let description = match.groups.description;
  const references = [];
  for (const m of description.matchAll(PullRequestRE)) {
    references.push({ type: "pull-request", value: m[1] });
  }
  for (const m of description.matchAll(IssueRE)) {
    if (!references.some((i) => i.value === m[1])) {
      references.push({ type: "issue", value: m[1] });
    }
  }
  references.push({ value: commit.shortHash, type: "hash" });
  description = description.replace(PullRequestRE, "").trim();
  const authors = [commit.author];
  for (const match2 of commit.body.matchAll(CoAuthoredByRegex)) {
    authors.push({
      name: (match2.groups.name || "").trim(),
      email: (match2.groups.email || "").trim()
    });
  }
  return {
    ...commit,
    authors,
    description,
    type,
    scope,
    references,
    isBreaking
  };
}
async function execCommand(cmd, args) {
  const { execa } = await import('execa');
  const res = await execa(cmd, args);
  return res.stdout;
}

async function generateMarkDown(commits, config) {
  const typeGroups = groupBy(commits, "type");
  const markdown = [];
  const breakingChanges = [];
  const v = config.newVersion && `v${config.newVersion}`;
  markdown.push("", "## " + (v || `${config.from}...${config.to}`), "");
  if (config.github) {
    markdown.push(
      `[compare changes](https://github.com/${config.github}/compare/${config.from}...${v || config.to})`,
      ""
    );
  }
  for (const type in config.types) {
    const group = typeGroups[type];
    if (!group || group.length === 0) {
      continue;
    }
    markdown.push("", "### " + config.types[type].title, "");
    for (const commit of group.reverse()) {
      const line = formatCommit(commit, config);
      markdown.push(line);
      if (commit.isBreaking) {
        breakingChanges.push(line);
      }
    }
  }
  if (breakingChanges.length > 0) {
    markdown.push("", "#### \u26A0\uFE0F  Breaking Changes", "", ...breakingChanges);
  }
  const _authors = /* @__PURE__ */ new Map();
  for (const commit of commits) {
    if (!commit.author) {
      continue;
    }
    const name = formatName(commit.author.name);
    if (!name || name.includes("[bot]")) {
      continue;
    }
    if (!_authors.has(name)) {
      _authors.set(name, { email: /* @__PURE__ */ new Set([commit.author.email]) });
    } else {
      const entry = _authors.get(name);
      entry.email.add(commit.author.email);
    }
  }
  await Promise.all(
    [..._authors.keys()].map(async (authorName) => {
      const meta = _authors.get(authorName);
      for (const email of meta.email) {
        const { user } = await nodeFetchNative.fetch(`https://ungh.unjs.io/user/find/${email}`).then((r) => r.json()).catch(() => ({ user: null }));
        if (user) {
          meta.github = user.username;
          break;
        }
      }
    })
  );
  const authors = [..._authors.entries()].map((e) => ({ name: e[0], ...e[1] }));
  if (authors.length > 0) {
    markdown.push(
      "",
      "### \u2764\uFE0F  Contributors",
      "",
      ...authors.map((i) => {
        const _email = [...i.email].find(
          (e) => !e.includes("noreply.github.com")
        );
        const email = _email ? `<${_email}>` : "";
        const github = i.github ? `([@${i.github}](http://github.com/${i.github}))` : "";
        return `- ${i.name} ${github || email}`;
      })
    );
  }
  return convertGitmoji.convert(markdown.join("\n").trim(), true);
}
function formatCommit(commit, config) {
  return "  - " + (commit.scope ? `**${commit.scope.trim()}:** ` : "") + (commit.isBreaking ? "\u26A0\uFE0F  " : "") + scule.upperFirst(commit.description) + formatReferences(commit.references, config);
}
const refTypeMap = {
  "pull-request": "pull",
  hash: "commit",
  issue: "ssue"
};
function formatReference(ref, config) {
  if (!config.github) {
    return ref.value;
  }
  return `[${ref.value}](https://github.com/${config.github}/${refTypeMap[ref.type]}/${ref.value.replace(/^#/, "")})`;
}
function formatReferences(references, config) {
  const pr = references.filter((ref) => ref.type === "pull-request");
  const issue = references.filter((ref) => ref.type === "issue");
  if (pr.length > 0 || issue.length > 0) {
    return " (" + [...pr, ...issue].map((ref) => formatReference(ref, config)).join(", ") + ")";
  }
  if (references.length > 0) {
    return " (" + formatReference(references[0], config) + ")";
  }
  return "";
}
function formatName(name = "") {
  return name.split(" ").map((p) => scule.upperFirst(p.trim())).join(" ");
}
function groupBy(items, key) {
  const groups = {};
  for (const item of items) {
    groups[item[key]] = groups[item[key]] || [];
    groups[item[key]].push(item);
  }
  return groups;
}

const ConfigDefaults = {
  types: {
    feat: { title: "\u{1F680} Enhancements", semver: "minor" },
    perf: { title: "\u{1F525} Performance", semver: "patch" },
    fix: { title: "\u{1FA79} Fixes", semver: "patch" },
    refactor: { title: "\u{1F485} Refactors", semver: "patch" },
    docs: { title: "\u{1F4D6} Documentation", semver: "patch" },
    build: { title: "\u{1F4E6} Build", semver: "patch" },
    types: { title: "\u{1F30A} Types", semver: "patch" },
    chore: { title: "\u{1F3E1} Chore" },
    examples: { title: "\u{1F3C0} Examples" },
    test: { title: "\u2705 Tests" },
    style: { title: "\u{1F3A8} Styles" },
    ci: { title: "\u{1F916} CI" }
  },
  cwd: null,
  github: "",
  from: "",
  to: "",
  output: "CHANGELOG.md",
  scopeMap: {}
};
async function loadChangelogConfig(cwd, overrides) {
  const { config } = await c12.loadConfig({
    cwd,
    name: "changelog",
    defaults: ConfigDefaults,
    overrides: {
      cwd,
      ...overrides
    }
  });
  if (!config.from) {
    config.from = await getLastGitTag();
  }
  if (!config.to) {
    config.to = await getCurrentGitRef();
  }
  if (!config.output) {
    config.output = false;
  } else if (config.output) {
    config.output = config.output === true ? ConfigDefaults.output : node_path.resolve(cwd, config.output);
  }
  if (!config.github) {
    const pkg = await pkgTypes.readPackageJSON(cwd).catch(() => {
    });
    if (pkg && pkg.repository) {
      const repo = typeof pkg.repository === "string" ? pkg.repository : pkg.repository.url;
      if (/^\w+\/\w+$/.test(repo)) {
        config.github = repo;
      }
    }
  }
  return config;
}

function determineSemverChange(commits, config) {
  let [hasMajor, hasMinor, hasPatch] = [false, false, false];
  for (const commit of commits) {
    const semverType = config.types[commit.type]?.semver;
    if (semverType === "major" || commit.isBreaking) {
      hasMajor = true;
    } else if (semverType === "minor") {
      hasMinor = true;
    } else if (semverType === "patch") {
      hasPatch = true;
    }
  }
  return hasMajor ? "major" : hasMinor ? "minor" : hasPatch ? "patch" : null;
}
async function bumpVersion(commits, config) {
  let type = determineSemverChange(commits, config) || "patch";
  const originalType = type;
  const pkgPath = node_path.resolve(config.cwd, "package.json");
  const pkg = JSON.parse(await node_fs.promises.readFile(pkgPath, "utf8").catch(() => "{}")) || {};
  const currentVersion = pkg.version || "0.0.0";
  if (currentVersion.startsWith("0.")) {
    if (type === "major") {
      type = "minor";
    } else if (type === "minor") {
      type = "patch";
    }
  }
  if (config.newVersion) {
    pkg.version = config.newVersion;
  } else if (type) {
    pkg.version = semver.inc(currentVersion, type);
    config.newVersion = pkg.version;
  }
  if (pkg.version === currentVersion) {
    return false;
  }
  consola.info(
    `Bumping version from ${currentVersion} to ${pkg.version} (${originalType})`
  );
  await node_fs.promises.writeFile(pkgPath, JSON.stringify(pkg, null, 2) + "\n", "utf8");
  return pkg.version;
}

exports.bumpVersion = bumpVersion;
exports.determineSemverChange = determineSemverChange;
exports.generateMarkDown = generateMarkDown;
exports.getCurrentGitBranch = getCurrentGitBranch;
exports.getCurrentGitRef = getCurrentGitRef;
exports.getCurrentGitTag = getCurrentGitTag;
exports.getGitDiff = getGitDiff;
exports.getLastGitTag = getLastGitTag;
exports.loadChangelogConfig = loadChangelogConfig;
exports.parseCommits = parseCommits;
exports.parseGitCommit = parseGitCommit;
