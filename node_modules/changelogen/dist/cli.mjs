#!/usr/bin/env node
import { resolve } from 'node:path';
import { existsSync, promises } from 'node:fs';
import consola from 'consola';
import mri from 'mri';
import { execa } from 'execa';
import { l as loadChangelogConfig, d as getGitDiff, p as parseCommits, i as bumpVersion, f as generateMarkDown } from './shared/changelogen.bc7e3def.mjs';
import 'scule';
import 'convert-gitmoji';
import 'node-fetch-native';
import 'c12';
import 'pkg-types';
import 'semver';

async function main() {
  const args = mri(process.argv.splice(2));
  const cwd = resolve(args._[0] || "");
  process.chdir(cwd);
  const config = await loadChangelogConfig(cwd, {
    from: args.from,
    to: args.to,
    output: args.output,
    newVersion: args.r
  });
  const logger = consola.create({ stdout: process.stderr });
  logger.info(`Generating changelog for ${config.from}...${config.to}`);
  const rawCommits = await getGitDiff(config.from, config.to);
  const commits = parseCommits(rawCommits, config).filter(
    (c) => config.types[c.type] && !(c.type === "chore" && c.scope === "deps" && !c.isBreaking)
  );
  if (args.bump || args.release) {
    const newVersion = await bumpVersion(commits, config);
    if (!newVersion) {
      consola.error("Unable to bump version based on changes.");
      process.exit(1);
    }
    config.newVersion = newVersion;
  }
  const markdown = await generateMarkDown(commits, config);
  const displayOnly = !args.bump && !args.release;
  if (displayOnly) {
    consola.log("\n\n" + markdown + "\n\n");
  }
  if (typeof config.output === "string" && (args.output || !displayOnly)) {
    let changelogMD;
    if (existsSync(config.output)) {
      consola.info(`Updating ${config.output}`);
      changelogMD = await promises.readFile(config.output, "utf8");
    } else {
      consola.info(`Creating  ${config.output}`);
      changelogMD = "# Changelog\n\n";
    }
    const lastEntry = changelogMD.match(/^###?\s+.*$/m);
    if (lastEntry) {
      changelogMD = changelogMD.slice(0, lastEntry.index) + markdown + "\n\n" + changelogMD.slice(lastEntry.index);
    } else {
      changelogMD += "\n" + markdown + "\n\n";
    }
    await promises.writeFile(config.output, changelogMD);
  }
  if (args.release) {
    if (args.commit !== false) {
      await execa(
        "git",
        ["commit", "-am", `chore(release): v${config.newVersion}`],
        { cwd }
      );
    }
    if (args.tag !== false) {
      await execa(
        "git",
        ["tag", "-am", "v" + config.newVersion, "v" + config.newVersion],
        { cwd }
      );
    }
  }
}
main().catch(consola.error);
